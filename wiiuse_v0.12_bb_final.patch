Binary files wiiuse_v0.12/.DS_Store and wiiuse_v0.12_bb_final/.DS_Store differ
diff -crN wiiuse_v0.12/example/example_bb.c wiiuse_v0.12_bb_final/example/example_bb.c
*** wiiuse_v0.12/example/example_bb.c	1970-01-01 01:00:00.000000000 +0100
--- wiiuse_v0.12_bb_final/example/example_bb.c	2009-10-07 10:19:02.000000000 +0200
***************
*** 0 ****
--- 1,330 ----
+ /*
+  *	wiiuse
+  *
+  *	Written By:
+  *		Michael Laforest	< para >
+  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
+  *
+  *	Copyright 2006-2007
+  *
+  *	This file is part of wiiuse.
+  *
+  *	This program is free software; you can redistribute it and/or modify
+  *	it under the terms of the GNU General Public License as published by
+  *	the Free Software Foundation; either version 3 of the License, or
+  *	(at your option) any later version.
+  *
+  *	This program is distributed in the hope that it will be useful,
+  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *	GNU General Public License for more details.
+  *
+  *	You should have received a copy of the GNU General Public License
+  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  *	$Header$
+  *
+  */
+ 
+ /**
+  *	@file
+  *
+  *	@brief Example using the wiiuse API.
+  *
+  *	This file is an example of how to use the wiiuse library.
+  */
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+ 
+ #ifndef WIN32
+ 	#include <unistd.h>
+ #endif
+ 
+ #include "wiiuse.h"
+ 
+ 
+ #define MAX_WIIMOTES				4
+ 
+ 
+ /**
+  *	@brief Callback that handles an event.
+  *
+  *	@param wm		Pointer to a wiimote_t structure.
+  *
+  *	This function is called automatically by the wiiuse library when an
+  *	event occurs on the specified wiimote.
+  */
+ void handle_event(struct wiimote_t* wm) {
+ 
+ 	/* if a button is pressed, report it */
+ 	if (IS_PRESSED(wm, WIIMOTE_BUTTON_A))
+ 	{
+ 		printf("A pressed\n");
+ 		wiiuse_set_wii_board_calib(wm);
+ 	}
+ 
+ 	/* show events specific to supported expansions */
+ 	if (wm->exp.type == EXP_WII_BOARD)
+ 	{
+ 		short ptr, ptl, pbr, pbl;
+ 		struct wii_board_t* wb = (wii_board_t*)&wm->exp.wb;
+ 		ptr = wb->tr;
+ 		ptl = wb->tl;
+ 		pbr = wb->br;
+ 		pbl = wb->bl;
+ 		printf("PTR: %5d PTL: %5d PBR: %5d PBL: %5d\nWeight: %d\n\n",ptr, ptl, pbr, pbl, (ptr+ptl+pbr+pbl)/4);
+ 	}
+ }
+ 
+ 
+ /**
+  *	@brief Callback that handles a read event.
+  *
+  *	@param wm		Pointer to a wiimote_t structure.
+  *	@param data		Pointer to the filled data block.
+  *	@param len		Length in bytes of the data block.
+  *
+  *	This function is called automatically by the wiiuse library when
+  *	the wiimote has returned the full data requested by a previous
+  *	call to wiiuse_read_data().
+  *
+  *	You can read data on the wiimote, such as Mii data, if
+  *	you know the offset address and the length.
+  *
+  *	The \a data pointer was specified on the call to wiiuse_read_data().
+  *	At the time of this function being called, it is not safe to deallocate
+  *	this buffer.
+  */
+ void handle_read(struct wiimote_t* wm, byte* data, unsigned short len) {
+ 	int i = 0;
+ 
+ 	printf("\n\n--- DATA READ [wiimote id %i] ---\n", wm->unid);
+ 	printf("finished read of size %i\n", len);
+ 	for (; i < len; ++i) {
+ 		if (!(i%16))
+ 			printf("\n");
+ 		printf("%x ", data[i]);
+ 	}
+ 	printf("\n\n");
+ }
+ 
+ 
+ /**
+  *	@brief Callback that handles a controller status event.
+  *
+  *	@param wm				Pointer to a wiimote_t structure.
+  *	@param attachment		Is there an attachment? (1 for yes, 0 for no)
+  *	@param speaker			Is the speaker enabled? (1 for yes, 0 for no)
+  *	@param ir				Is the IR support enabled? (1 for yes, 0 for no)
+  *	@param led				What LEDs are lit.
+  *	@param battery_level	Battery level, between 0.0 (0%) and 1.0 (100%).
+  *
+  *	This occurs when either the controller status changed
+  *	or the controller status was requested explicitly by
+  *	wiiuse_status().
+  *
+  *	One reason the status can change is if the nunchuk was
+  *	inserted or removed from the expansion port.
+  */
+ void handle_ctrl_status(struct wiimote_t* wm) {
+ 	printf("\n\n--- CONTROLLER STATUS [wiimote id %i] ---\n", wm->unid);
+ 
+ 	printf("attachment:      %i\n", wm->exp.type);
+ 	printf("speaker:         %i\n", WIIUSE_USING_SPEAKER(wm));
+ 	printf("ir:              %i\n", WIIUSE_USING_IR(wm));
+ 	printf("leds:            %i %i %i %i\n", WIIUSE_IS_LED_SET(wm, 1), WIIUSE_IS_LED_SET(wm, 2), WIIUSE_IS_LED_SET(wm, 3), WIIUSE_IS_LED_SET(wm, 4));
+ 	printf("battery:         %f %%\n", wm->battery_level);
+ }
+ 
+ 
+ /**
+  *	@brief Callback that handles a disconnection event.
+  *
+  *	@param wm				Pointer to a wiimote_t structure.
+  *
+  *	This can happen if the POWER button is pressed, or
+  *	if the connection is interrupted.
+  */
+ void handle_disconnect(wiimote* wm) {
+ 	printf("\n\n--- DISCONNECTED [wiimote id %i] ---\n", wm->unid);
+ }
+ 
+ 
+ void test(struct wiimote_t* wm, byte* data, unsigned short len) {
+ 	printf("test: %i [%x %x %x %x]\n", len, data[0], data[1], data[2], data[3]);
+ }
+ 
+ 
+ 
+ /**
+  *	@brief main()
+  *
+  *	Connect to up to two wiimotes and print any events
+  *	that occur on either device.
+  */
+ int main(int argc, char** argv) {
+ 	wiimote** wiimotes;
+ 	int found, connected;
+ 
+ 	/*
+ 	 *	Initialize an array of wiimote objects.
+ 	 *
+ 	 *	The parameter is the number of wiimotes I want to create.
+ 	 */
+ 	wiimotes =  wiiuse_init(MAX_WIIMOTES);
+ 
+ 	/*
+ 	 *	Find wiimote devices
+ 	 *
+ 	 *	Now we need to find some wiimotes.
+ 	 *	Give the function the wiimote array we created, and tell it there
+ 	 *	are MAX_WIIMOTES wiimotes we are interested in.
+ 	 *
+ 	 *	Set the timeout to be 5 seconds.
+ 	 *
+ 	 *	This will return the number of actual wiimotes that are in discovery mode.
+ 	 */
+ 	found = wiiuse_find(wiimotes, MAX_WIIMOTES, 5);
+ 	if (!found) {
+ 		printf ("No wiimotes found.");
+ 		return 0;
+ 	}
+ 
+ 	/*
+ 	 *	Connect to the wiimotes
+ 	 *
+ 	 *	Now that we found some wiimotes, connect to them.
+ 	 *	Give the function the wiimote array and the number
+ 	 *	of wiimote devices we found.
+ 	 *
+ 	 *	This will return the number of established connections to the found wiimotes.
+ 	 */
+ 	connected = wiiuse_connect(wiimotes, MAX_WIIMOTES);
+ 	if (connected)
+ 		printf("Connected to %i wiimotes (of %i found).\n", connected, found);
+ 	else {
+ 		printf("Failed to connect to any wiimote.\n");
+ 		return 0;
+ 	}
+ 
+ 	/*
+ 	 *	Now set the LEDs and rumble for a second so it's easy
+ 	 *	to tell which wiimotes are connected (just like the wii does).
+ 	 */
+ 	wiiuse_set_leds(wiimotes[0], WIIMOTE_LED_1);
+ 	wiiuse_set_leds(wiimotes[1], WIIMOTE_LED_2);
+ 	wiiuse_set_leds(wiimotes[2], WIIMOTE_LED_3);
+ 	wiiuse_set_leds(wiimotes[3], WIIMOTE_LED_4);
+ 	wiiuse_rumble(wiimotes[0], 1);
+ 	wiiuse_rumble(wiimotes[1], 1);
+ 
+ 	#ifndef WIN32
+ 		usleep(200000);
+ 	#else
+ 		Sleep(200);
+ 	#endif
+ 
+ 	wiiuse_rumble(wiimotes[0], 0);
+ 	wiiuse_rumble(wiimotes[1], 0);
+ 
+ 	/*
+ 	 *	Maybe I'm interested in the battery power of the 0th
+ 	 *	wiimote.  This should be WIIMOTE_ID_1 but to be sure
+ 	 *	you can get the wiimote assoicated with WIIMOTE_ID_1
+ 	 *	using the wiiuse_get_by_id() function.
+ 	 *
+ 	 *	A status request will return other things too, like
+ 	 *	if any expansions are plugged into the wiimote or
+ 	 *	what LEDs are lit.
+ 	 */
+ 	//wiiuse_status(wiimotes[0]);
+ 
+ 	/*
+ 	 *	This is the main loop
+ 	 *
+ 	 *	wiiuse_poll() needs to be called with the wiimote array
+ 	 *	and the number of wiimote structures in that array
+ 	 *	(it doesn't matter if some of those wiimotes are not used
+ 	 *	or are not connected).
+ 	 *
+ 	 *	This function will set the event flag for each wiimote
+ 	 *	when the wiimote has things to report.
+ 	 */
+ 	while (1) {
+ 		if (wiiuse_poll(wiimotes, MAX_WIIMOTES)) {
+ 			/*
+ 			 *	This happens if something happened on any wiimote.
+ 			 *	So go through each one and check if anything happened.
+ 			 */
+ 			int i = 0;
+ 			for (; i < MAX_WIIMOTES; ++i) {
+ 				switch (wiimotes[i]->event) {
+ 					case WIIUSE_EVENT:
+ 						/* a generic event occured */
+ 						handle_event(wiimotes[i]);
+ 						break;
+ 
+ 					case WIIUSE_STATUS:
+ 						/* a status event occured */
+ 						handle_ctrl_status(wiimotes[i]);
+ 						break;
+ 
+ 					case WIIUSE_DISCONNECT:
+ 					case WIIUSE_UNEXPECTED_DISCONNECT:
+ 						/* the wiimote disconnected */
+ 						handle_disconnect(wiimotes[i]);
+ 						break;
+ 
+ 					case WIIUSE_READ_DATA:
+ 						/*
+ 						 *	Data we requested to read was returned.
+ 						 *	Take a look at wiimotes[i]->read_req
+ 						 *	for the data.
+ 						 */
+ 						break;
+ 
+ 					case WIIUSE_NUNCHUK_INSERTED:
+ 						/*
+ 						 *	a nunchuk was inserted
+ 						 *	This is a good place to set any nunchuk specific
+ 						 *	threshold values.  By default they are the same
+ 						 *	as the wiimote.
+ 						 */
+ 						 //wiiuse_set_nunchuk_orient_threshold((struct nunchuk_t*)&wiimotes[i]->exp.nunchuk, 90.0f);
+ 						 //wiiuse_set_nunchuk_accel_threshold((struct nunchuk_t*)&wiimotes[i]->exp.nunchuk, 100);
+ 						printf("Nunchuk inserted.\n");
+ 						break;
+ 
+ 					case WIIUSE_CLASSIC_CTRL_INSERTED:
+ 						printf("Classic controller inserted.\n");
+ 						break;
+ 
+ 					case WIIUSE_WII_BOARD_CTRL_INSERTED:
+ 						/* some expansion was inserted */
+ 						printf("Wii Balance Board detected.\n");
+ 						break;
+ 
+ 					case WIIUSE_NUNCHUK_REMOVED:
+ 					case WIIUSE_CLASSIC_CTRL_REMOVED:
+ 					case WIIUSE_GUITAR_HERO_3_CTRL_REMOVED:
+ 					case WIIUSE_WII_BOARD_CTRL_REMOVED:
+ 						/* some expansion was removed */
+ 						handle_ctrl_status(wiimotes[i]);
+ 						printf("An expansion was removed.\n");
+ 						break;
+ 
+ 					default:
+ 						break;
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	/*
+ 	 *	Disconnect the wiimotes
+ 	 */
+ 	wiiuse_cleanup(wiimotes, MAX_WIIMOTES);
+ 
+ 	return 0;
+ }
diff -crN wiiuse_v0.12/src/Makefile wiiuse_v0.12_bb_final/src/Makefile
*** wiiuse_v0.12/src/Makefile	2008-03-03 00:30:04.000000000 +0100
--- wiiuse_v0.12_bb_final/src/Makefile	2008-04-25 22:05:44.000000000 +0200
***************
*** 56,61 ****
--- 56,62 ----
  	$(OBJ_DIR)/ir.o \
  	$(OBJ_DIR)/nunchuk.o \
  	$(OBJ_DIR)/guitar_hero_3.o \
+ 	$(OBJ_DIR)/wiiboard.o \
  	$(OBJ_DIR)/wiiuse.o
  
  ###############################
diff -crN wiiuse_v0.12/src/classic.c wiiuse_v0.12_bb_final/src/classic.c
*** wiiuse_v0.12/src/classic.c	2008-03-28 00:03:58.000000000 +0100
--- wiiuse_v0.12_bb_final/src/classic.c	2009-10-09 10:26:38.000000000 +0200
***************
*** 1,74 ****
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Classic controller expansion device.
!  */
! 
! #include <stdio.h>
! #include <stdlib.h>
! #include <math.h>
! 
! #ifdef WIN32
! 	#include <Winsock2.h>
! #endif
! 
! #include "definitions.h"
! #include "wiiuse_internal.h"
! #include "dynamics.h"
! #include "events.h"
! #include "classic.h"
! 
! static void classic_ctrl_pressed_buttons(struct classic_ctrl_t* cc, short now);
! 
! /**
!  *	@brief Handle the handshake data from the classic controller.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param data		The data read in from the device.
!  *	@param len		The length of the data block, in bytes.
!  *
!  *	@return	Returns 1 if handshake was successful, 0 if not.
!  */
! int classic_ctrl_handshake(struct wiimote_t* wm, struct classic_ctrl_t* cc, byte* data, unsigned short len) {
  	int i;
! 	int offset = 0;
! 
! 	cc->btns = 0;
! 	cc->btns_held = 0;
! 	cc->btns_released = 0;
! 	cc->r_shoulder = 0;
! 	cc->l_shoulder = 0;
! 
! 	/* decrypt data */
! 	for (i = 0; i < len; ++i)
! 		data[i] = (data[i] ^ 0x17) + 0x17;
  
  	if (data[offset] == 0xFF) {
  		/*
--- 1,74 ----
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Classic controller expansion device.
!  */
! 
! #include <stdio.h>
! #include <stdlib.h>
! #include <math.h>
! 
! #ifdef WIN32
! 	#include <Winsock2.h>
! #endif
! 
! #include "definitions.h"
! #include "wiiuse_internal.h"
! #include "dynamics.h"
! #include "events.h"
! #include "classic.h"
! 
! static void classic_ctrl_pressed_buttons(struct classic_ctrl_t* cc, short now);
! 
! /**
!  *	@brief Handle the handshake data from the classic controller.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param data		The data read in from the device.
!  *	@param len		The length of the data block, in bytes.
!  *
!  *	@return	Returns 1 if handshake was successful, 0 if not.
!  */
! int classic_ctrl_handshake(struct wiimote_t* wm, struct classic_ctrl_t* cc, byte* data, unsigned short len) {
  	int i;
! 	int offset = 0;
! 
! 	cc->btns = 0;
! 	cc->btns_held = 0;
! 	cc->btns_released = 0;
! 	cc->r_shoulder = 0;
! 	cc->l_shoulder = 0;
! 
! 	/* decrypt data */
! 	for (i = 0; i < len; ++i)
! 		data[i] = (data[i] ^ 0x17) + 0x17;
  
  	if (data[offset] == 0xFF) {
  		/*
***************
*** 93,190 ****
  			offset += 16;
  	}
  
! 
! 	/* joystick stuff */
! 	cc->ljs.max.x = data[0 + offset] / 4;
! 	cc->ljs.min.x = data[1 + offset] / 4;
! 	cc->ljs.center.x = data[2 + offset] / 4;
! 	cc->ljs.max.y = data[3 + offset] / 4;
! 	cc->ljs.min.y = data[4 + offset] / 4;
! 	cc->ljs.center.y = data[5 + offset] / 4;
! 
! 	cc->rjs.max.x = data[6 + offset] / 8;
! 	cc->rjs.min.x = data[7 + offset] / 8;
! 	cc->rjs.center.x = data[8 + offset] / 8;
! 	cc->rjs.max.y = data[9 + offset] / 8;
! 	cc->rjs.min.y = data[10 + offset] / 8;
! 	cc->rjs.center.y = data[11 + offset] / 8;
! 
! 	/* handshake done */
! 	wm->exp.type = EXP_CLASSIC;
! 
! 	#ifdef WIN32
! 	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
! 	#endif
! 
! 	return 1;
! }
! 
! 
! /**
!  *	@brief The classic controller disconnected.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  */
! void classic_ctrl_disconnected(struct classic_ctrl_t* cc) {
! 	memset(cc, 0, sizeof(struct classic_ctrl_t));
! }
! 
! 
! 
! /**
!  *	@brief Handle classic controller event.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param msg		The message specified in the event packet.
!  */
! void classic_ctrl_event(struct classic_ctrl_t* cc, byte* msg) {
! 	int i, lx, ly, rx, ry;
! 	byte l, r;
! 
! 	/* decrypt data */
! 	for (i = 0; i < 6; ++i)
! 		msg[i] = (msg[i] ^ 0x17) + 0x17;
! 
! 	classic_ctrl_pressed_buttons(cc, BIG_ENDIAN_SHORT(*(short*)(msg + 4)));
! 
! 	/* left/right buttons */
! 	l = (((msg[2] & 0x60) >> 2) | ((msg[3] & 0xE0) >> 5));
! 	r = (msg[3] & 0x1F);
! 
! 	/*
! 	 *	TODO - LR range hardcoded from 0x00 to 0x1F.
! 	 *	This is probably in the calibration somewhere.
! 	 */
! 	cc->r_shoulder = ((float)r / 0x1F);
! 	cc->l_shoulder = ((float)l / 0x1F);
! 
! 	/* calculate joystick orientation */
! 	lx = (msg[0] & 0x3F);
! 	ly = (msg[1] & 0x3F);
! 	rx = ((msg[0] & 0xC0) >> 3) | ((msg[1] & 0xC0) >> 5) | ((msg[2] & 0x80) >> 7);
! 	ry = (msg[2] & 0x1F);
! 
! 	calc_joystick_state(&cc->ljs, lx, ly);
! 	calc_joystick_state(&cc->rjs, rx, ry);
! }
! 
! 
! /**
!  *	@brief Find what buttons are pressed.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param msg		The message byte specified in the event packet.
!  */
! static void classic_ctrl_pressed_buttons(struct classic_ctrl_t* cc, short now) {
! 	/* message is inverted (0 is active, 1 is inactive) */
! 	now = ~now & CLASSIC_CTRL_BUTTON_ALL;
! 
! 	/* pressed now & were pressed, then held */
! 	cc->btns_held = (now & cc->btns);
! 
! 	/* were pressed or were held & not pressed now, then released */
! 	cc->btns_released = ((cc->btns | cc->btns_held) & ~now);
! 
! 	/* buttons pressed now */
! 	cc->btns = now;
! }
--- 93,190 ----
  			offset += 16;
  	}
  
! 
! 	/* joystick stuff */
! 	cc->ljs.max.x = data[0 + offset] / 4;
! 	cc->ljs.min.x = data[1 + offset] / 4;
! 	cc->ljs.center.x = data[2 + offset] / 4;
! 	cc->ljs.max.y = data[3 + offset] / 4;
! 	cc->ljs.min.y = data[4 + offset] / 4;
! 	cc->ljs.center.y = data[5 + offset] / 4;
! 
! 	cc->rjs.max.x = data[6 + offset] / 8;
! 	cc->rjs.min.x = data[7 + offset] / 8;
! 	cc->rjs.center.x = data[8 + offset] / 8;
! 	cc->rjs.max.y = data[9 + offset] / 8;
! 	cc->rjs.min.y = data[10 + offset] / 8;
! 	cc->rjs.center.y = data[11 + offset] / 8;
! 
! 	/* handshake done */
! 	wm->exp.type = EXP_CLASSIC;
! 
! 	#ifdef WIN32
! 	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
! 	#endif
! 
! 	return 1;
! }
! 
! 
! /**
!  *	@brief The classic controller disconnected.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  */
! void classic_ctrl_disconnected(struct classic_ctrl_t* cc) {
! 	memset(cc, 0, sizeof(struct classic_ctrl_t));
! }
! 
! 
! 
! /**
!  *	@brief Handle classic controller event.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param msg		The message specified in the event packet.
!  */
! void classic_ctrl_event(struct classic_ctrl_t* cc, byte* msg) {
! 	int i, lx, ly, rx, ry;
! 	byte l, r;
! 
! 	/* decrypt data */
! 	for (i = 0; i < 6; ++i)
! 		msg[i] = (msg[i] ^ 0x17) + 0x17;
! 
! 	classic_ctrl_pressed_buttons(cc, BIG_ENDIAN_SHORT(*(short*)(msg + 4)));
! 
! 	/* left/right buttons */
! 	l = (((msg[2] & 0x60) >> 2) | ((msg[3] & 0xE0) >> 5));
! 	r = (msg[3] & 0x1F);
! 
! 	/*
! 	 *	TODO - LR range hardcoded from 0x00 to 0x1F.
! 	 *	This is probably in the calibration somewhere.
! 	 */
! 	cc->r_shoulder = ((float)r / 0x1F);
! 	cc->l_shoulder = ((float)l / 0x1F);
! 
! 	/* calculate joystick orientation */
! 	lx = (msg[0] & 0x3F);
! 	ly = (msg[1] & 0x3F);
! 	rx = ((msg[0] & 0xC0) >> 3) | ((msg[1] & 0xC0) >> 5) | ((msg[2] & 0x80) >> 7);
! 	ry = (msg[2] & 0x1F);
! 
! 	calc_joystick_state(&cc->ljs, lx, ly);
! 	calc_joystick_state(&cc->rjs, rx, ry);
! }
! 
! 
! /**
!  *	@brief Find what buttons are pressed.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param msg		The message byte specified in the event packet.
!  */
! static void classic_ctrl_pressed_buttons(struct classic_ctrl_t* cc, short now) {
! 	/* message is inverted (0 is active, 1 is inactive) */
! 	now = ~now & CLASSIC_CTRL_BUTTON_ALL;
! 
! 	/* pressed now & were pressed, then held */
! 	cc->btns_held = (now & cc->btns);
! 
! 	/* were pressed or were held & not pressed now, then released */
! 	cc->btns_released = ((cc->btns | cc->btns_held) & ~now);
! 
! 	/* buttons pressed now */
! 	cc->btns = now;
! }
diff -crN wiiuse_v0.12/src/definitions.h wiiuse_v0.12_bb_final/src/definitions.h
*** wiiuse_v0.12/src/definitions.h	2008-04-02 03:39:35.000000000 +0200
--- wiiuse_v0.12_bb_final/src/definitions.h	2009-10-14 10:05:14.000000000 +0200
***************
*** 1,55 ****
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief General definitions.
!  */
! 
! #ifndef DEFINITIONS_H_INCLUDED
! #define DEFINITIONS_H_INCLUDED
! 
! /* this is wiiuse - used to distinguish from third party programs using wiiuse.h */
! #include "os.h"
! 
! #define WIIMOTE_PI			3.14159265f
! 
! //#define WITH_WIIUSE_DEBUG
! 
! /* Error output macros */
! #define WIIUSE_ERROR(fmt, ...)		fprintf(stderr, "[ERROR] " fmt "\n", ##__VA_ARGS__)
! 
! /* Warning output macros */
! #define WIIUSE_WARNING(fmt, ...)	fprintf(stderr, "[WARNING] " fmt "\n",	##__VA_ARGS__)
! 
! /* Information output macros */
! #define WIIUSE_INFO(fmt, ...)		fprintf(stderr, "[INFO] " fmt "\n", ##__VA_ARGS__)
! 
  #ifdef WITH_WIIUSE_DEBUG
  	#ifdef WIN32
  		#define WIIUSE_DEBUG(fmt, ...)		do {																				\
--- 1,55 ----
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief General definitions.
!  */
! 
! #ifndef DEFINITIONS_H_INCLUDED
! #define DEFINITIONS_H_INCLUDED
! 
! /* this is wiiuse - used to distinguish from third party programs using wiiuse.h */
! #include "os.h"
! 
! #define WIIMOTE_PI			3.14159265f
! 
! //#define WITH_WIIUSE_DEBUG
! 
! /* Error output macros */
! #define WIIUSE_ERROR(fmt, ...)		fprintf(stderr, "[ERROR] " fmt "\n", ##__VA_ARGS__)
! 
! /* Warning output macros */
! #define WIIUSE_WARNING(fmt, ...)	fprintf(stderr, "[WARNING] " fmt "\n",	##__VA_ARGS__)
! 
! /* Information output macros */
! #define WIIUSE_INFO(fmt, ...)		fprintf(stderr, "[INFO] " fmt "\n", ##__VA_ARGS__)
! 
  #ifdef WITH_WIIUSE_DEBUG
  	#ifdef WIN32
  		#define WIIUSE_DEBUG(fmt, ...)		do {																				\
***************
*** 58,79 ****
  												for (; i && (file[i] != '\\'); --i);											\
  												fprintf(stderr, "[DEBUG] %s:%i: " fmt "\n", file+i+1, __LINE__, ##__VA_ARGS__);	\
  											} while (0)
! 	#else
  		#define WIIUSE_DEBUG(fmt, ...)	fprintf(stderr, "[DEBUG] " __FILE__ ":%i: " fmt "\n", __LINE__, ##__VA_ARGS__)
! 	#endif
! #else
! 	#define WIIUSE_DEBUG(fmt, ...)
! #endif
! 
! /* Convert between radians and degrees */
! #define RAD_TO_DEGREE(r)	((r * 180.0f) / WIIMOTE_PI)
! #define DEGREE_TO_RAD(d)	(d * (WIIMOTE_PI / 180.0f))
! 
! /* Convert to big endian */
! #define BIG_ENDIAN_LONG(i)				(htonl(i))
! #define BIG_ENDIAN_SHORT(i)				(htons(i))
! 
! #define absf(x)						((x >= 0) ? (x) : (x * -1.0f))
! #define diff_f(x, y)				((x >= y) ? (absf(x - y)) : (absf(y - x)))
! 
! #endif // DEFINITIONS_H_INCLUDED
--- 58,82 ----
  												for (; i && (file[i] != '\\'); --i);											\
  												fprintf(stderr, "[DEBUG] %s:%i: " fmt "\n", file+i+1, __LINE__, ##__VA_ARGS__);	\
  											} while (0)
! 	#else
  		#define WIIUSE_DEBUG(fmt, ...)	fprintf(stderr, "[DEBUG] " __FILE__ ":%i: " fmt "\n", __LINE__, ##__VA_ARGS__)
! 	#endif
! #else
! 	#define WIIUSE_DEBUG(fmt, ...)
! #endif
! 
! /* Convert between radians and degrees */
! #define RAD_TO_DEGREE(r)	((r * 180.0f) / WIIMOTE_PI)
! #define DEGREE_TO_RAD(d)	(d * (WIIMOTE_PI / 180.0f))
! 
! /* Convert to big endian */
! #define BIG_ENDIAN_LONG(i)				(htonl(i))
! #define BIG_ENDIAN_SHORT(i)				(htons(i))
! 
! #define absf(x)						((x >= 0) ? (x) : (x * -1.0f))
! #define diff_f(x, y)				((x >= y) ? (absf(x - y)) : (absf(y - x)))
! 
! /* Balance Board max value */
! #define MAX_WB_VAL 136
! 
! #endif // DEFINITIONS_H_INCLUDED
diff -crN wiiuse_v0.12/src/events.c wiiuse_v0.12_bb_final/src/events.c
*** wiiuse_v0.12/src/events.c	2008-04-02 01:13:47.000000000 +0200
--- wiiuse_v0.12_bb_final/src/events.c	2009-10-12 11:10:24.000000000 +0200
***************
*** 39,47 ****
  #ifndef WIN32
  	#include <sys/time.h>
  	#include <unistd.h>
! 	#include <errno.h>
  #else
! 	#include <winsock2.h>
  #endif
  
  #include <sys/types.h>
--- 39,47 ----
  #ifndef WIN32
  	#include <sys/time.h>
  	#include <unistd.h>
! 	#include <errno.h>
  #else
! 	#include <winsock2.h>
  #endif
  
  #include <sys/types.h>
***************
*** 56,65 ****
  #include "nunchuk.h"
  #include "classic.h"
  #include "guitar_hero_3.h"
  #include "events.h"
  
  static void idle_cycle(struct wiimote_t* wm);
! static void clear_dirty_reads(struct wiimote_t* wm);
  static void propagate_event(struct wiimote_t* wm, byte event, byte* msg);
  static void event_data_read(struct wiimote_t* wm, byte* msg);
  static void event_status(struct wiimote_t* wm, byte* msg);
--- 56,66 ----
  #include "nunchuk.h"
  #include "classic.h"
  #include "guitar_hero_3.h"
+ #include "wiiboard.h"
  #include "events.h"
  
  static void idle_cycle(struct wiimote_t* wm);
! static void clear_dirty_reads(struct wiimote_t* wm);
  static void propagate_event(struct wiimote_t* wm, byte event, byte* msg);
  static void event_data_read(struct wiimote_t* wm, byte* msg);
  static void event_status(struct wiimote_t* wm, byte* msg);
***************
*** 132,155 ****
  
  			if (FD_ISSET(wm[i]->in_sock, &fds)) {
  				/* clear out the event buffer */
! 				memset(wm[i]->event_buf, 0, sizeof(wm[i]->event_buf));
! 
! 				/* clear out any old read requests */
  				clear_dirty_reads(wm[i]);
  
  				/* read the pending message into the buffer */
  				r = read(wm[i]->in_sock, wm[i]->event_buf, sizeof(wm[i]->event_buf));
  				if (r == -1) {
  					/* error reading data */
! 					WIIUSE_ERROR("Receiving wiimote data (id %i).", wm[i]->unid);
! 					perror("Error Details");
! 
! 					if (errno == ENOTCONN) {
! 						/* this can happen if the bluetooth dongle is disconnected */
! 						WIIUSE_ERROR("Bluetooth appears to be disconnected.  Wiimote unid %i will be disconnected.", wm[i]->unid);
! 						wiiuse_disconnect(wm[i]);
! 						wm[i]->event = WIIUSE_UNEXPECTED_DISCONNECT;
! 					}
  
  					continue;
  				}
--- 133,156 ----
  
  			if (FD_ISSET(wm[i]->in_sock, &fds)) {
  				/* clear out the event buffer */
! 				memset(wm[i]->event_buf, 0, sizeof(wm[i]->event_buf));
! 
! 				/* clear out any old read requests */
  				clear_dirty_reads(wm[i]);
  
  				/* read the pending message into the buffer */
  				r = read(wm[i]->in_sock, wm[i]->event_buf, sizeof(wm[i]->event_buf));
  				if (r == -1) {
  					/* error reading data */
! 					WIIUSE_ERROR("Receiving wiimote data (id %i).", wm[i]->unid);
! 					perror("Error Details");
! 
! 					if (errno == ENOTCONN) {
! 						/* this can happen if the bluetooth dongle is disconnected */
! 						WIIUSE_ERROR("Bluetooth appears to be disconnected.  Wiimote unid %i will be disconnected.", wm[i]->unid);
! 						wiiuse_disconnect(wm[i]);
! 						wm[i]->event = WIIUSE_UNEXPECTED_DISCONNECT;
! 					}
  
  					continue;
  				}
***************
*** 216,242 ****
  		apply_smoothing(&wm->accel_calib, &wm->orient, SMOOTH_ROLL);
  		apply_smoothing(&wm->accel_calib, &wm->orient, SMOOTH_PITCH);
  	}
! 
! 	/* clear out any old read requests */
! 	clear_dirty_reads(wm);
! }
! 
! 
! /**
!  *	@brief Clear out all old 'dirty' read requests.
!  *
!  *	@param wm		Pointer to a wiimote_t structure.
!  */
! static void clear_dirty_reads(struct wiimote_t* wm) {
! 	struct read_req_t* req = wm->read_req;
! 
! 	while (req && req->dirty) {
! 		WIIUSE_DEBUG("Cleared old read request for address: %x", req->addr);
! 
! 		wm->read_req = req->next;
! 		free(req);
! 		req = wm->read_req;
! 	}
  }
  
  
--- 217,243 ----
  		apply_smoothing(&wm->accel_calib, &wm->orient, SMOOTH_ROLL);
  		apply_smoothing(&wm->accel_calib, &wm->orient, SMOOTH_PITCH);
  	}
! 
! 	/* clear out any old read requests */
! 	clear_dirty_reads(wm);
! }
! 
! 
! /**
!  *	@brief Clear out all old 'dirty' read requests.
!  *
!  *	@param wm		Pointer to a wiimote_t structure.
!  */
! static void clear_dirty_reads(struct wiimote_t* wm) {
! 	struct read_req_t* req = wm->read_req;
! 
! 	while (req && req->dirty) {
! 		WIIUSE_DEBUG("Cleared old read request for address: %x", req->addr);
! 
! 		wm->read_req = req->next;
! 		free(req);
! 		req = wm->read_req;
! 	}
  }
  
  
***************
*** 424,433 ****
  	struct read_req_t* req = wm->read_req;
  
  	wiiuse_pressed_buttons(wm, msg);
! 
! 	/* find the next non-dirty request */
! 	while (req && req->dirty)
! 		req = req->next;
  
  	/* if we don't have a request out then we didn't ask for this packet */
  	if (!req) {
--- 425,434 ----
  	struct read_req_t* req = wm->read_req;
  
  	wiiuse_pressed_buttons(wm, msg);
! 
! 	/* find the next non-dirty request */
! 	while (req && req->dirty)
! 		req = req->next;
  
  	/* if we don't have a request out then we didn't ask for this packet */
  	if (!req) {
***************
*** 488,511 ****
  	#endif
  
  	/* if all data has been received, execute the read event callback or generate event */
! 	if (!req->wait) {
! 		if (req->cb) {
  			/* this was a callback, so invoke it now */
  			req->cb(wm, req->buf, req->size);
  
  			/* delete this request */
  			wm->read_req = req->next;
! 			free(req);
! 		} else {
! 			/*
! 			 *	This should generate an event.
! 			 *	We need to leave the event in the array so the client
! 			 *	can access it still.  We'll flag is as being 'dirty'
! 			 *	and give the client one cycle to use it.  Next event
! 			 *	we will remove it from the list.
! 			 */
! 			wm->event = WIIUSE_READ_DATA;
! 			req->dirty = 1;
  		}
  
  		/* if another request exists send it to the wiimote */
--- 489,512 ----
  	#endif
  
  	/* if all data has been received, execute the read event callback or generate event */
! 	if (!req->wait) {
! 		if (req->cb) {
  			/* this was a callback, so invoke it now */
  			req->cb(wm, req->buf, req->size);
  
  			/* delete this request */
  			wm->read_req = req->next;
! 			free(req);
! 		} else {
! 			/*
! 			 *	This should generate an event.
! 			 *	We need to leave the event in the array so the client
! 			 *	can access it still.  We'll flag is as being 'dirty'
! 			 *	and give the client one cycle to use it.  Next event
! 			 *	we will remove it from the list.
! 			 */
! 			wm->event = WIIUSE_READ_DATA;
! 			req->dirty = 1;
  		}
  
  		/* if another request exists send it to the wiimote */
***************
*** 611,616 ****
--- 612,620 ----
  		case EXP_GUITAR_HERO_3:
  			guitar_hero_3_event(&wm->exp.gh3, msg);
  			break;
+ 		case EXP_WII_BOARD:
+ 			wii_board_event(&wm->exp.wb, msg);
+ 			break;
  		default:
  			break;
  	}
***************
*** 669,677 ****
  			break;
  		}
  		case EXP_ID_CODE_CLASSIC_CONTROLLER:
! 		{
  			if (classic_ctrl_handshake(wm, &wm->exp.classic, data, len))
! 				wm->event = WIIUSE_CLASSIC_CTRL_INSERTED;
  			break;
  		}
  		case EXP_ID_CODE_GUITAR:
--- 673,681 ----
  			break;
  		}
  		case EXP_ID_CODE_CLASSIC_CONTROLLER:
! 		{
  			if (classic_ctrl_handshake(wm, &wm->exp.classic, data, len))
! 				wm->event = WIIUSE_CLASSIC_CTRL_INSERTED;
  			break;
  		}
  		case EXP_ID_CODE_GUITAR:
***************
*** 680,685 ****
--- 684,695 ----
  				wm->event = WIIUSE_GUITAR_HERO_3_CTRL_INSERTED;
  			break;
  		}
+ 		case EXP_ID_CODE_WII_BOARD:
+ 		{
+ 			if (wii_board_handshake(wm, &wm->exp.wb, data, len))
+ 				wm->event = WIIUSE_WII_BOARD_CTRL_INSERTED;
+ 			break;
+ 		}
  		default:
  		{
  			WIIUSE_WARNING("Unknown expansion type. Code: 0x%x", id);
***************
*** 720,725 ****
--- 730,739 ----
  			guitar_hero_3_disconnected(&wm->exp.gh3);
  			wm->event = WIIUSE_GUITAR_HERO_3_CTRL_REMOVED;
  			break;
+ 		case EXP_WII_BOARD:
+ 			guitar_hero_3_disconnected(&wm->exp.gh3);
+ 			wm->event = WIIUSE_GUITAR_HERO_3_CTRL_REMOVED;
+ 			break;
  		default:
  			break;
  	}
***************
*** 866,871 ****
--- 880,893 ----
  			STATE_CHANGED(wm->lstate.exp_btns, wm->exp.gh3.btns);
  			break;
  		}
+ 		case EXP_WII_BOARD:
+ 		{
+ 			STATE_CHANGED(wm->exp.wb.prev.tr,wm->exp.wb.raw.tr);
+ 			STATE_CHANGED(wm->exp.wb.prev.tl,wm->exp.wb.raw.tl);
+ 			STATE_CHANGED(wm->exp.wb.prev.br,wm->exp.wb.raw.br);
+ 			STATE_CHANGED(wm->exp.wb.prev.bl,wm->exp.wb.raw.bl);
+ 			break;
+ 		}
  		case EXP_NONE:
  		{
  			break;
diff -crN wiiuse_v0.12/src/events.h wiiuse_v0.12_bb_final/src/events.h
*** wiiuse_v0.12/src/events.h	2008-02-12 02:22:37.000000000 +0100
--- wiiuse_v0.12_bb_final/src/events.h	2009-10-09 10:26:38.000000000 +0200
***************
*** 1,54 ****
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Handles wiimote events.
!  *
!  *	The file includes functions that handle the events
!  *	that are sent from the wiimote to us.
!  */
! 
! #ifndef EVENTS_H_INCLUDED
! #define EVENTS_H_INCLUDED
! 
! #ifdef __cplusplus
! extern "C" {
! #endif
! 
! void wiiuse_pressed_buttons(struct wiimote_t* wm, byte* msg);
! 
! void handshake_expansion(struct wiimote_t* wm, byte* data, unsigned short len);
  void disable_expansion(struct wiimote_t* wm);
! 
! #ifdef __cplusplus
! }
! #endif
! 
! 
! #endif // EVENTS_H_INCLUDED
--- 1,54 ----
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Handles wiimote events.
!  *
!  *	The file includes functions that handle the events
!  *	that are sent from the wiimote to us.
!  */
! 
! #ifndef EVENTS_H_INCLUDED
! #define EVENTS_H_INCLUDED
! 
! #ifdef __cplusplus
! extern "C" {
! #endif
! 
! void wiiuse_pressed_buttons(struct wiimote_t* wm, byte* msg);
! 
! void handshake_expansion(struct wiimote_t* wm, byte* data, unsigned short len);
  void disable_expansion(struct wiimote_t* wm);
! 
! #ifdef __cplusplus
! }
! #endif
! 
! 
! #endif // EVENTS_H_INCLUDED
diff -crN wiiuse_v0.12/src/guitar_hero_3.c wiiuse_v0.12_bb_final/src/guitar_hero_3.c
*** wiiuse_v0.12/src/guitar_hero_3.c	2008-03-28 00:04:43.000000000 +0100
--- wiiuse_v0.12_bb_final/src/guitar_hero_3.c	2009-10-09 10:26:38.000000000 +0200
***************
*** 1,79 ****
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Guitar Hero 3 expansion device.
!  */
! 
! #include <stdio.h>
! #include <stdlib.h>
! #include <math.h>
! 
! #ifdef WIN32
! 	#include <Winsock2.h>
! #endif
! 
! #include "definitions.h"
! #include "wiiuse_internal.h"
! #include "dynamics.h"
! #include "events.h"
! #include "guitar_hero_3.h"
! 
! static void guitar_hero_3_pressed_buttons(struct guitar_hero_3_t* gh3, short now);
! 
! /**
!  *	@brief Handle the handshake data from the guitar.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param data		The data read in from the device.
!  *	@param len		The length of the data block, in bytes.
!  *
!  *	@return	Returns 1 if handshake was successful, 0 if not.
!  */
! int guitar_hero_3_handshake(struct wiimote_t* wm, struct guitar_hero_3_t* gh3, byte* data, unsigned short len) {
  	int i;
! 	int offset = 0;
! 
! 	/*
! 	 *	The good fellows that made the Guitar Hero 3 controller
! 	 *	failed to factory calibrate the devices.  There is no
! 	 *	calibration data on the device.
! 	 */
! 
! 	gh3->btns = 0;
! 	gh3->btns_held = 0;
! 	gh3->btns_released = 0;
! 	gh3->whammy_bar = 0.0f;
! 
! 	/* decrypt data */
! 	for (i = 0; i < len; ++i)
! 		data[i] = (data[i] ^ 0x17) + 0x17;
  
  	if (data[offset] == 0xFF) {
  		/*
--- 1,79 ----
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Guitar Hero 3 expansion device.
!  */
! 
! #include <stdio.h>
! #include <stdlib.h>
! #include <math.h>
! 
! #ifdef WIN32
! 	#include <Winsock2.h>
! #endif
! 
! #include "definitions.h"
! #include "wiiuse_internal.h"
! #include "dynamics.h"
! #include "events.h"
! #include "guitar_hero_3.h"
! 
! static void guitar_hero_3_pressed_buttons(struct guitar_hero_3_t* gh3, short now);
! 
! /**
!  *	@brief Handle the handshake data from the guitar.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param data		The data read in from the device.
!  *	@param len		The length of the data block, in bytes.
!  *
!  *	@return	Returns 1 if handshake was successful, 0 if not.
!  */
! int guitar_hero_3_handshake(struct wiimote_t* wm, struct guitar_hero_3_t* gh3, byte* data, unsigned short len) {
  	int i;
! 	int offset = 0;
! 
! 	/*
! 	 *	The good fellows that made the Guitar Hero 3 controller
! 	 *	failed to factory calibrate the devices.  There is no
! 	 *	calibration data on the device.
! 	 */
! 
! 	gh3->btns = 0;
! 	gh3->btns_held = 0;
! 	gh3->btns_released = 0;
! 	gh3->whammy_bar = 0.0f;
! 
! 	/* decrypt data */
! 	for (i = 0; i < len; ++i)
! 		data[i] = (data[i] ^ 0x17) + 0x17;
  
  	if (data[offset] == 0xFF) {
  		/*
***************
*** 97,172 ****
  		} else
  			offset += 16;
  	}
! 
! 	/* joystick stuff */
! 	gh3->js.max.x = GUITAR_HERO_3_JS_MAX_X;
! 	gh3->js.min.x = GUITAR_HERO_3_JS_MIN_X;
! 	gh3->js.center.x = GUITAR_HERO_3_JS_CENTER_X;
! 	gh3->js.max.y = GUITAR_HERO_3_JS_MAX_Y;
! 	gh3->js.min.y = GUITAR_HERO_3_JS_MIN_Y;
! 	gh3->js.center.y = GUITAR_HERO_3_JS_CENTER_Y;
! 
! 	/* handshake done */
! 	wm->exp.type = EXP_GUITAR_HERO_3;
! 
! 	#ifdef WIN32
! 	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
! 	#endif
! 
! 	return 1;
! }
! 
! 
! /**
!  *	@brief The guitar disconnected.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  */
! void guitar_hero_3_disconnected(struct guitar_hero_3_t* gh3) {
! 	memset(gh3, 0, sizeof(struct guitar_hero_3_t));
! }
! 
! 
! 
! /**
!  *	@brief Handle guitar event.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param msg		The message specified in the event packet.
!  */
! void guitar_hero_3_event(struct guitar_hero_3_t* gh3, byte* msg) {
! 	int i;
! 
! 	/* decrypt data */
! 	for (i = 0; i < 6; ++i)
! 		msg[i] = (msg[i] ^ 0x17) + 0x17;
! 
! 	guitar_hero_3_pressed_buttons(gh3, BIG_ENDIAN_SHORT(*(short*)(msg + 4)));
! 
! 	/* whammy bar */
! 	gh3->whammy_bar = (msg[3] - GUITAR_HERO_3_WHAMMY_BAR_MIN) / (float)(GUITAR_HERO_3_WHAMMY_BAR_MAX - GUITAR_HERO_3_WHAMMY_BAR_MIN);
! 
! 	/* joy stick */
! 	calc_joystick_state(&gh3->js, msg[0], msg[1]);
! }
! 
! 
! /**
!  *	@brief Find what buttons are pressed.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param msg		The message byte specified in the event packet.
!  */
! static void guitar_hero_3_pressed_buttons(struct guitar_hero_3_t* gh3, short now) {
! 	/* message is inverted (0 is active, 1 is inactive) */
! 	now = ~now & GUITAR_HERO_3_BUTTON_ALL;
! 
! 	/* pressed now & were pressed, then held */
! 	gh3->btns_held = (now & gh3->btns);
! 
! 	/* were pressed or were held & not pressed now, then released */
! 	gh3->btns_released = ((gh3->btns | gh3->btns_held) & ~now);
! 
! 	/* buttons pressed now */
! 	gh3->btns = now;
! }
--- 97,172 ----
  		} else
  			offset += 16;
  	}
! 
! 	/* joystick stuff */
! 	gh3->js.max.x = GUITAR_HERO_3_JS_MAX_X;
! 	gh3->js.min.x = GUITAR_HERO_3_JS_MIN_X;
! 	gh3->js.center.x = GUITAR_HERO_3_JS_CENTER_X;
! 	gh3->js.max.y = GUITAR_HERO_3_JS_MAX_Y;
! 	gh3->js.min.y = GUITAR_HERO_3_JS_MIN_Y;
! 	gh3->js.center.y = GUITAR_HERO_3_JS_CENTER_Y;
! 
! 	/* handshake done */
! 	wm->exp.type = EXP_GUITAR_HERO_3;
! 
! 	#ifdef WIN32
! 	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
! 	#endif
! 
! 	return 1;
! }
! 
! 
! /**
!  *	@brief The guitar disconnected.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  */
! void guitar_hero_3_disconnected(struct guitar_hero_3_t* gh3) {
! 	memset(gh3, 0, sizeof(struct guitar_hero_3_t));
! }
! 
! 
! 
! /**
!  *	@brief Handle guitar event.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param msg		The message specified in the event packet.
!  */
! void guitar_hero_3_event(struct guitar_hero_3_t* gh3, byte* msg) {
! 	int i;
! 
! 	/* decrypt data */
! 	for (i = 0; i < 6; ++i)
! 		msg[i] = (msg[i] ^ 0x17) + 0x17;
! 
! 	guitar_hero_3_pressed_buttons(gh3, BIG_ENDIAN_SHORT(*(short*)(msg + 4)));
! 
! 	/* whammy bar */
! 	gh3->whammy_bar = (msg[3] - GUITAR_HERO_3_WHAMMY_BAR_MIN) / (float)(GUITAR_HERO_3_WHAMMY_BAR_MAX - GUITAR_HERO_3_WHAMMY_BAR_MIN);
! 
! 	/* joy stick */
! 	calc_joystick_state(&gh3->js, msg[0], msg[1]);
! }
! 
! 
! /**
!  *	@brief Find what buttons are pressed.
!  *
!  *	@param cc		A pointer to a classic_ctrl_t structure.
!  *	@param msg		The message byte specified in the event packet.
!  */
! static void guitar_hero_3_pressed_buttons(struct guitar_hero_3_t* gh3, short now) {
! 	/* message is inverted (0 is active, 1 is inactive) */
! 	now = ~now & GUITAR_HERO_3_BUTTON_ALL;
! 
! 	/* pressed now & were pressed, then held */
! 	gh3->btns_held = (now & gh3->btns);
! 
! 	/* were pressed or were held & not pressed now, then released */
! 	gh3->btns_released = ((gh3->btns | gh3->btns_held) & ~now);
! 
! 	/* buttons pressed now */
! 	gh3->btns = now;
! }
diff -crN wiiuse_v0.12/src/io.c wiiuse_v0.12_bb_final/src/io.c
*** wiiuse_v0.12/src/io.c	2008-03-28 00:04:09.000000000 +0100
--- wiiuse_v0.12_bb_final/src/io.c	2009-10-12 11:10:24.000000000 +0200
***************
*** 1,119 ****
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Handles device I/O (non-OS specific).
!  */
! 
! #include <stdio.h>
! #include <stdlib.h>
! 
! #include "definitions.h"
! #include "wiiuse_internal.h"
! #include "io.h"
! 
! 
!  /**
!  *	@brief Get initialization data from the wiimote.
!  *
!  *	@param wm		Pointer to a wiimote_t structure.
!  *	@param data		unused
!  *	@param len		unused
!  *
!  *	When first called for a wiimote_t structure, a request
!  *	is sent to the wiimote for initialization information.
!  *	This includes factory set accelerometer data.
!  *	The handshake will be concluded when the wiimote responds
!  *	with this data.
!  */
! void wiiuse_handshake(struct wiimote_t* wm, byte* data, unsigned short len) {
! 	if (!wm)	return;
! 
! 	switch (wm->handshake_state) {
! 		case 0:
! 		{
! 			/* send request to wiimote for accelerometer calibration */
  			byte* buf;
  
! 			WIIMOTE_ENABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
! 			wiiuse_set_leds(wm, WIIMOTE_LED_NONE);
! 
! 			buf = (byte*)malloc(sizeof(byte) * 8);
! 			wiiuse_read_data_cb(wm, wiiuse_handshake, buf, WM_MEM_OFFSET_CALIBRATION, 7);
! 			wm->handshake_state++;
! 
  			wiiuse_set_leds(wm, WIIMOTE_LED_NONE);
  
! 			break;
! 		}
! 		case 1:
! 		{
! 			struct read_req_t* req = wm->read_req;
! 			struct accel_t* accel = &wm->accel_calib;
! 
! 			/* received read data */
! 			accel->cal_zero.x = req->buf[0];
! 			accel->cal_zero.y = req->buf[1];
! 			accel->cal_zero.z = req->buf[2];
! 
! 			accel->cal_g.x = req->buf[4] - accel->cal_zero.x;
! 			accel->cal_g.y = req->buf[5] - accel->cal_zero.y;
! 			accel->cal_g.z = req->buf[6] - accel->cal_zero.z;
! 
! 			/* done with the buffer */
! 			free(req->buf);
! 
! 			/* handshake is done */
! 			WIIUSE_DEBUG("Handshake finished. Calibration: Idle: X=%x Y=%x Z=%x\t+1g: X=%x Y=%x Z=%x",
! 					accel->cal_zero.x, accel->cal_zero.y, accel->cal_zero.z,
! 					accel->cal_g.x, accel->cal_g.y, accel->cal_g.z);
! 
  
  			/* request the status of the wiimote to see if there is an expansion */
  			wiiuse_status(wm);
  
! 			WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
! 			WIIMOTE_ENABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE_COMPLETE);
  			wm->handshake_state++;
  
  			/* now enable IR if it was set before the handshake completed */
  			if (WIIMOTE_IS_SET(wm, WIIMOTE_STATE_IR)) {
! 				WIIUSE_DEBUG("Handshake finished, enabling IR.");
! 				WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_IR);
! 				wiiuse_set_ir(wm, 1);
  			}
! 
! 			break;
  		}
! 		default:
! 		{
! 			break;
! 		}
! 	}
! }
--- 1,119 ----
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Handles device I/O (non-OS specific).
!  */
! 
! #include <stdio.h>
! #include <stdlib.h>
! 
! #include "definitions.h"
! #include "wiiuse_internal.h"
! #include "io.h"
! 
! 
!  /**
!  *	@brief Get initialization data from the wiimote.
!  *
!  *	@param wm		Pointer to a wiimote_t structure.
!  *	@param data		unused
!  *	@param len		unused
!  *
!  *	When first called for a wiimote_t structure, a request
!  *	is sent to the wiimote for initialization information.
!  *	This includes factory set accelerometer data.
!  *	The handshake will be concluded when the wiimote responds
!  *	with this data.
!  */
! void wiiuse_handshake(struct wiimote_t* wm, byte* data, unsigned short len) {
! 	if (!wm)	return;
! 
! 	switch (wm->handshake_state) {
! 		case 0:
! 		{
! 			/* send request to wiimote for accelerometer calibration */
  			byte* buf;
  
! 			WIIMOTE_ENABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
! 			wiiuse_set_leds(wm, WIIMOTE_LED_NONE);
! 
! 			buf = (byte*)malloc(sizeof(byte) * 8);
! 			wiiuse_read_data_cb(wm, wiiuse_handshake, buf, WM_MEM_OFFSET_CALIBRATION, 7);
! 			wm->handshake_state++;
! 
  			wiiuse_set_leds(wm, WIIMOTE_LED_NONE);
  
! 			break;
! 		}
! 		case 1:
! 		{
! 			struct read_req_t* req = wm->read_req;
! 			struct accel_t* accel = &wm->accel_calib;
! 
! 			/* received read data */
! 			accel->cal_zero.x = req->buf[0];
! 			accel->cal_zero.y = req->buf[1];
! 			accel->cal_zero.z = req->buf[2];
! 
! 			accel->cal_g.x = req->buf[4] - accel->cal_zero.x;
! 			accel->cal_g.y = req->buf[5] - accel->cal_zero.y;
! 			accel->cal_g.z = req->buf[6] - accel->cal_zero.z;
! 
! 			/* done with the buffer */
! 			free(req->buf);
! 
! 			/* handshake is done */
! 			WIIUSE_DEBUG("Handshake finished. Calibration: Idle: X=%x Y=%x Z=%x\t+1g: X=%x Y=%x Z=%x",
! 					accel->cal_zero.x, accel->cal_zero.y, accel->cal_zero.z,
! 					accel->cal_g.x, accel->cal_g.y, accel->cal_g.z);
! 
  
  			/* request the status of the wiimote to see if there is an expansion */
  			wiiuse_status(wm);
  
! 			WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
! 			WIIMOTE_ENABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE_COMPLETE);
  			wm->handshake_state++;
  
  			/* now enable IR if it was set before the handshake completed */
  			if (WIIMOTE_IS_SET(wm, WIIMOTE_STATE_IR)) {
! 				WIIUSE_DEBUG("Handshake finished, enabling IR.");
! 				WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_IR);
! 				wiiuse_set_ir(wm, 1);
  			}
! 
! 			break;
! 		}
! 		default:
! 		{
! 			break;
  		}
! 	}
! }
diff -crN wiiuse_v0.12/src/io_win.c wiiuse_v0.12_bb_final/src/io_win.c
*** wiiuse_v0.12/src/io_win.c	2008-03-29 22:53:44.000000000 +0100
--- wiiuse_v0.12_bb_final/src/io_win.c	2009-10-06 15:25:00.000000000 +0200
***************
*** 1,247 ****
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Handles device I/O for Windows.
!  */
! 
! #ifdef WIN32
! 
! #include <stdio.h>
! #include <stdlib.h>
! 
! #include <windows.h>
! #include <hidsdi.h>
! #include <setupapi.h>
! 
! #include "definitions.h"
! #include "wiiuse_internal.h"
! #include "io.h"
! 
! 
! int wiiuse_find(struct wiimote_t** wm, int max_wiimotes, int timeout) {
! 	GUID device_id;
! 	HANDLE dev;
! 	HDEVINFO device_info;
! 	int i, index;
! 	DWORD len;
! 	SP_DEVICE_INTERFACE_DATA device_data;
! 	PSP_DEVICE_INTERFACE_DETAIL_DATA detail_data = NULL;
! 	HIDD_ATTRIBUTES	attr;
! 	int found = 0;
! 
! 	(void) timeout; // unused
! 
! 	device_data.cbSize = sizeof(device_data);
! 	index = 0;
! 
! 	/* get the device id */
! 	HidD_GetHidGuid(&device_id);
! 
! 	/* get all hid devices connected */
! 	device_info = SetupDiGetClassDevs(&device_id, NULL, NULL, (DIGCF_DEVICEINTERFACE | DIGCF_PRESENT));
! 
! 	for (;; ++index) {
! 
! 		if (detail_data) {
! 			free(detail_data);
! 			detail_data = NULL;
! 		}
! 
! 		/* query the next hid device info */
! 		if (!SetupDiEnumDeviceInterfaces(device_info, NULL, &device_id, index, &device_data))
! 			break;
! 
! 		/* get the size of the data block required */
! 		i = SetupDiGetDeviceInterfaceDetail(device_info, &device_data, NULL, 0, &len, NULL);
! 		detail_data = malloc(len);
! 		detail_data->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
! 
! 		/* query the data for this device */
! 		if (!SetupDiGetDeviceInterfaceDetail(device_info, &device_data, detail_data, len, NULL, NULL))
! 			continue;
! 
! 		/* open the device */
! 		dev = CreateFile(detail_data->DevicePath,
! 						(GENERIC_READ | GENERIC_WRITE),
! 						(FILE_SHARE_READ | FILE_SHARE_WRITE),
! 						NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
! 		if (dev == INVALID_HANDLE_VALUE)
! 			continue;
! 
! 		/* get device attributes */
! 		attr.Size = sizeof(attr);
! 		i = HidD_GetAttributes(dev, &attr);
! 
! 		if ((attr.VendorID == WM_VENDOR_ID) && (attr.ProductID == WM_PRODUCT_ID)) {
! 			/* this is a wiimote */
! 			wm[found]->dev_handle = dev;
! 
! 			wm[found]->hid_overlap.hEvent = CreateEvent(NULL, 1, 1, "");
! 			wm[found]->hid_overlap.Offset = 0;
! 			wm[found]->hid_overlap.OffsetHigh = 0;
! 
! 			WIIMOTE_ENABLE_STATE(wm[found], WIIMOTE_STATE_DEV_FOUND);
! 			WIIMOTE_ENABLE_STATE(wm[found], WIIMOTE_STATE_CONNECTED);
! 
! 			/* try to set the output report to see if the device is actually connected */
! 			if (!wiiuse_set_report_type(wm[found])) {
! 				WIIMOTE_DISABLE_STATE(wm[found], WIIMOTE_STATE_CONNECTED);
! 				continue;
! 			}
! 
! 			/* do the handshake */
! 			wiiuse_handshake(wm[found], NULL, 0);
! 
! 			WIIUSE_INFO("Connected to wiimote [id %i].", wm[found]->unid);
! 
! 			++found;
! 			if (found >= max_wiimotes)
! 				break;
! 		} else {
! 			/* not a wiimote */
! 			CloseHandle(dev);
! 		}
! 	}
! 
! 	if (detail_data)
! 		free(detail_data);
! 
! 	SetupDiDestroyDeviceInfoList(device_info);
! 
! 	return found;
! }
! 
! 
! int wiiuse_connect(struct wiimote_t** wm, int wiimotes) {
! 	int connected = 0;
! 	int i = 0;
! 
! 	for (; i < wiimotes; ++i) {
! 		if (WIIMOTE_IS_SET(wm[i], WIIMOTE_STATE_CONNECTED))
! 			++connected;
! 	}
! 
! 	return connected;
! }
! 
! 
! void wiiuse_disconnect(struct wiimote_t* wm) {
! 	if (!wm || WIIMOTE_IS_CONNECTED(wm))
! 		return;
! 
! 	CloseHandle(wm->dev_handle);
! 	wm->dev_handle = 0;
! 
! 	ResetEvent(&wm->hid_overlap);
! 
! 	wm->event = WIIUSE_NONE;
! 
! 	WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_CONNECTED);
! 	WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
! }
! 
! 
! int wiiuse_io_read(struct wiimote_t* wm) {
! 	DWORD b, r;
! 
! 	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
! 		return 0;
! 
! 	if (!ReadFile(wm->dev_handle, wm->event_buf, sizeof(wm->event_buf), &b, &wm->hid_overlap)) {
! 		/* partial read */
  		b = GetLastError();
  
! 		if ((b == ERROR_HANDLE_EOF) || (b == ERROR_DEVICE_NOT_CONNECTED)) {
! 			/* remote disconnect */
! 			wiiuse_disconnected(wm);
! 			return 0;
! 		}
! 
! 		r = WaitForSingleObject(wm->hid_overlap.hEvent, wm->timeout);
! 		if (r == WAIT_TIMEOUT) {
  			/* timeout - cancel and continue */
  
  			if (*wm->event_buf)
  				WIIUSE_WARNING("Packet ignored.  This may indicate a problem (timeout is %i ms).", wm->timeout);
  
! 			CancelIo(wm->dev_handle);
! 			ResetEvent(wm->hid_overlap.hEvent);
! 			return 0;
! 		} else if (r == WAIT_FAILED) {
! 			WIIUSE_WARNING("A wait error occured on reading from wiimote %i.", wm->unid);
! 			return 0;
! 		}
! 
! 		if (!GetOverlappedResult(wm->dev_handle, &wm->hid_overlap, &b, 0))
! 			return 0;
! 	}
! 
  	ResetEvent(wm->hid_overlap.hEvent);
! 	return 1;
! }
! 
! 
! int wiiuse_io_write(struct wiimote_t* wm, byte* buf, int len) {
! 	DWORD bytes;
  	int i;
  
! 	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
  		return 0;
  
! 	switch (wm->stack) {
! 		case WIIUSE_STACK_UNKNOWN:
! 		{
! 			/* try to auto-detect the stack type */
! 			if (i = WriteFile(wm->dev_handle, buf, 22, &bytes, &wm->hid_overlap)) {
! 				/* bluesoleil will always return 1 here, even if it's not connected */
  				wm->stack = WIIUSE_STACK_BLUESOLEIL;
! 				return i;
! 			}
! 
! 			if (i = HidD_SetOutputReport(wm->dev_handle, buf, len)) {
! 				wm->stack = WIIUSE_STACK_MS;
! 				return i;
! 			}
! 
! 			WIIUSE_ERROR("Unable to determine bluetooth stack type.");
! 			return 0;
! 		}
! 
! 		case WIIUSE_STACK_MS:
! 			return HidD_SetOutputReport(wm->dev_handle, buf, len);
! 
! 		case WIIUSE_STACK_BLUESOLEIL:
! 			return WriteFile(wm->dev_handle, buf, 22, &bytes, &wm->hid_overlap);
! 	}
! 
! 	return 0;
! }
! 
! #endif /* ifdef WIN32 */
--- 1,247 ----
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Handles device I/O for Windows.
!  */
! 
! #ifdef WIN32
! 
! #include <stdio.h>
! #include <stdlib.h>
! 
! #include <windows.h>
! #include <api/hidsdi.h>
! #include <setupapi.h>
! 
! #include "definitions.h"
! #include "wiiuse_internal.h"
! #include "io.h"
! 
! 
! int wiiuse_find(struct wiimote_t** wm, int max_wiimotes, int timeout) {
! 	GUID device_id;
! 	HANDLE dev;
! 	HDEVINFO device_info;
! 	int i, index;
! 	DWORD len;
! 	SP_DEVICE_INTERFACE_DATA device_data;
! 	PSP_DEVICE_INTERFACE_DETAIL_DATA detail_data = NULL;
! 	HIDD_ATTRIBUTES	attr;
! 	int found = 0;
! 
! 	(void) timeout; // unused
! 
! 	device_data.cbSize = sizeof(device_data);
! 	index = 0;
! 
! 	/* get the device id */
! 	HidD_GetHidGuid(&device_id);
! 
! 	/* get all hid devices connected */
! 	device_info = SetupDiGetClassDevs(&device_id, NULL, NULL, (DIGCF_DEVICEINTERFACE | DIGCF_PRESENT));
! 
! 	for (;; ++index) {
! 
! 		if (detail_data) {
! 			free(detail_data);
! 			detail_data = NULL;
! 		}
! 
! 		/* query the next hid device info */
! 		if (!SetupDiEnumDeviceInterfaces(device_info, NULL, &device_id, index, &device_data))
! 			break;
! 
! 		/* get the size of the data block required */
! 		i = SetupDiGetDeviceInterfaceDetail(device_info, &device_data, NULL, 0, &len, NULL);
! 		detail_data = malloc(len);
! 		detail_data->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
! 
! 		/* query the data for this device */
! 		if (!SetupDiGetDeviceInterfaceDetail(device_info, &device_data, detail_data, len, NULL, NULL))
! 			continue;
! 
! 		/* open the device */
! 		dev = CreateFile(detail_data->DevicePath,
! 						(GENERIC_READ | GENERIC_WRITE),
! 						(FILE_SHARE_READ | FILE_SHARE_WRITE),
! 						NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
! 		if (dev == INVALID_HANDLE_VALUE)
! 			continue;
! 
! 		/* get device attributes */
! 		attr.Size = sizeof(attr);
! 		i = HidD_GetAttributes(dev, &attr);
! 
! 		if ((attr.VendorID == WM_VENDOR_ID) && (attr.ProductID == WM_PRODUCT_ID)) {
! 			/* this is a wiimote */
! 			wm[found]->dev_handle = dev;
! 
! 			wm[found]->hid_overlap.hEvent = CreateEvent(NULL, 1, 1, "");
! 			wm[found]->hid_overlap.Offset = 0;
! 			wm[found]->hid_overlap.OffsetHigh = 0;
! 
! 			WIIMOTE_ENABLE_STATE(wm[found], WIIMOTE_STATE_DEV_FOUND);
! 			WIIMOTE_ENABLE_STATE(wm[found], WIIMOTE_STATE_CONNECTED);
! 
! 			/* try to set the output report to see if the device is actually connected */
! 			if (!wiiuse_set_report_type(wm[found])) {
! 				WIIMOTE_DISABLE_STATE(wm[found], WIIMOTE_STATE_CONNECTED);
! 				continue;
! 			}
! 
! 			/* do the handshake */
! 			wiiuse_handshake(wm[found], NULL, 0);
! 
! 			WIIUSE_INFO("Connected to wiimote [id %i].", wm[found]->unid);
! 
! 			++found;
! 			if (found >= max_wiimotes)
! 				break;
! 		} else {
! 			/* not a wiimote */
! 			CloseHandle(dev);
! 		}
! 	}
! 
! 	if (detail_data)
! 		free(detail_data);
! 
! 	SetupDiDestroyDeviceInfoList(device_info);
! 
! 	return found;
! }
! 
! 
! int wiiuse_connect(struct wiimote_t** wm, int wiimotes) {
! 	int connected = 0;
! 	int i = 0;
! 
! 	for (; i < wiimotes; ++i) {
! 		if (WIIMOTE_IS_SET(wm[i], WIIMOTE_STATE_CONNECTED))
! 			++connected;
! 	}
! 
! 	return connected;
! }
! 
! 
! void wiiuse_disconnect(struct wiimote_t* wm) {
! 	if (!wm || WIIMOTE_IS_CONNECTED(wm))
! 		return;
! 
! 	CloseHandle(wm->dev_handle);
! 	wm->dev_handle = 0;
! 
! 	ResetEvent(&wm->hid_overlap);
! 
! 	wm->event = WIIUSE_NONE;
! 
! 	WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_CONNECTED);
! 	WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
! }
! 
! 
! int wiiuse_io_read(struct wiimote_t* wm) {
! 	DWORD b, r;
! 
! 	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
! 		return 0;
! 
! 	if (!ReadFile(wm->dev_handle, wm->event_buf, sizeof(wm->event_buf), &b, &wm->hid_overlap)) {
! 		/* partial read */
  		b = GetLastError();
  
! 		if ((b == ERROR_HANDLE_EOF) || (b == ERROR_DEVICE_NOT_CONNECTED)) {
! 			/* remote disconnect */
! 			wiiuse_disconnected(wm);
! 			return 0;
! 		}
! 
! 		r = WaitForSingleObject(wm->hid_overlap.hEvent, wm->timeout);
! 		if (r == WAIT_TIMEOUT) {
  			/* timeout - cancel and continue */
  
  			if (*wm->event_buf)
  				WIIUSE_WARNING("Packet ignored.  This may indicate a problem (timeout is %i ms).", wm->timeout);
  
! 			CancelIo(wm->dev_handle);
! 			ResetEvent(wm->hid_overlap.hEvent);
! 			return 0;
! 		} else if (r == WAIT_FAILED) {
! 			WIIUSE_WARNING("A wait error occured on reading from wiimote %i.", wm->unid);
! 			return 0;
! 		}
! 
! 		if (!GetOverlappedResult(wm->dev_handle, &wm->hid_overlap, &b, 0))
! 			return 0;
! 	}
! 
  	ResetEvent(wm->hid_overlap.hEvent);
! 	return 1;
! }
! 
! 
! int wiiuse_io_write(struct wiimote_t* wm, byte* buf, int len) {
! 	DWORD bytes;
  	int i;
  
! 	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
  		return 0;
  
! 	switch (wm->stack) {
! 		case WIIUSE_STACK_UNKNOWN:
! 		{
! 			/* try to auto-detect the stack type */
! 			if (i = WriteFile(wm->dev_handle, buf, 22, &bytes, &wm->hid_overlap)) {
! 				/* bluesoleil will always return 1 here, even if it's not connected */
  				wm->stack = WIIUSE_STACK_BLUESOLEIL;
! 				return i;
! 			}
! 
! 			if (i = HidD_SetOutputReport(wm->dev_handle, buf, len)) {
! 				wm->stack = WIIUSE_STACK_MS;
! 				return i;
! 			}
! 
! 			WIIUSE_ERROR("Unable to determine bluetooth stack type.");
! 			return 0;
! 		}
! 
! 		case WIIUSE_STACK_MS:
! 			return HidD_SetOutputReport(wm->dev_handle, buf, len);
! 
! 		case WIIUSE_STACK_BLUESOLEIL:
! 			return WriteFile(wm->dev_handle, buf, 22, &bytes, &wm->hid_overlap);
! 	}
! 
! 	return 0;
! }
! 
! #endif /* ifdef WIN32 */
Binary files wiiuse_v0.12/src/msvc/wiiuse.ncb and wiiuse_v0.12_bb_final/src/msvc/wiiuse.ncb differ
diff -crN wiiuse_v0.12/src/msvc/wiiuse.sln wiiuse_v0.12_bb_final/src/msvc/wiiuse.sln
*** wiiuse_v0.12/src/msvc/wiiuse.sln	1970-01-01 01:00:00.000000000 +0100
--- wiiuse_v0.12_bb_final/src/msvc/wiiuse.sln	2010-05-18 17:22:54.000000000 +0200
***************
*** 0 ****
--- 1,20 ----
+ ﻿
+ Microsoft Visual Studio Solution File, Format Version 11.00
+ # Visual Studio 2010
+ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wiiuse", "wiiuse.vcxproj", "{7E5ABF18-4A57-4ECA-BF8A-AA3C41165CBB}"
+ EndProject
+ Global
+ 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+ 		Debug|Win32 = Debug|Win32
+ 		Release|Win32 = Release|Win32
+ 	EndGlobalSection
+ 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+ 		{7E5ABF18-4A57-4ECA-BF8A-AA3C41165CBB}.Debug|Win32.ActiveCfg = Debug|Win32
+ 		{7E5ABF18-4A57-4ECA-BF8A-AA3C41165CBB}.Debug|Win32.Build.0 = Debug|Win32
+ 		{7E5ABF18-4A57-4ECA-BF8A-AA3C41165CBB}.Release|Win32.ActiveCfg = Release|Win32
+ 		{7E5ABF18-4A57-4ECA-BF8A-AA3C41165CBB}.Release|Win32.Build.0 = Release|Win32
+ 	EndGlobalSection
+ 	GlobalSection(SolutionProperties) = preSolution
+ 		HideSolutionNode = FALSE
+ 	EndGlobalSection
+ EndGlobal
diff -crN wiiuse_v0.12/src/msvc/wiiuse.vcproj wiiuse_v0.12_bb_final/src/msvc/wiiuse.vcproj
*** wiiuse_v0.12/src/msvc/wiiuse.vcproj	1970-01-01 01:00:00.000000000 +0100
--- wiiuse_v0.12_bb_final/src/msvc/wiiuse.vcproj	2009-10-09 12:05:52.000000000 +0200
***************
*** 0 ****
--- 1,485 ----
+ <?xml version="1.0" encoding="Windows-1252"?>
+ <VisualStudioProject
+ 	ProjectType="Visual C++"
+ 	Version="9,00"
+ 	Name="wiiuse"
+ 	ProjectGUID="{7E5ABF18-4A57-4ECA-BF8A-AA3C41165CBB}"
+ 	RootNamespace="wiiuse"
+ 	TargetFrameworkVersion="0"
+ 	>
+ 	<Platforms>
+ 		<Platform
+ 			Name="Win32"
+ 		/>
+ 	</Platforms>
+ 	<ToolFiles>
+ 	</ToolFiles>
+ 	<Configurations>
+ 		<Configuration
+ 			Name="Release|Win32"
+ 			OutputDirectory=".\Release"
+ 			IntermediateDirectory=".\Release"
+ 			ConfigurationType="2"
+ 			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+ 			UseOfMFC="0"
+ 			ATLMinimizesCRunTimeLibraryUsage="false"
+ 			CharacterSet="2"
+ 			>
+ 			<Tool
+ 				Name="VCPreBuildEventTool"
+ 			/>
+ 			<Tool
+ 				Name="VCCustomBuildTool"
+ 			/>
+ 			<Tool
+ 				Name="VCXMLDataGeneratorTool"
+ 			/>
+ 			<Tool
+ 				Name="VCWebServiceProxyGeneratorTool"
+ 			/>
+ 			<Tool
+ 				Name="VCMIDLTool"
+ 				PreprocessorDefinitions="NDEBUG"
+ 				MkTypLibCompatible="true"
+ 				SuppressStartupBanner="true"
+ 				TargetEnvironment="1"
+ 				TypeLibraryName=".\Release/wiiuse.tlb"
+ 				HeaderFileName=""
+ 			/>
+ 			<Tool
+ 				Name="VCCLCompilerTool"
+ 				Optimization="2"
+ 				InlineFunctionExpansion="1"
+ 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;WIIUSE_EXPORTS"
+ 				StringPooling="true"
+ 				RuntimeLibrary="0"
+ 				EnableFunctionLevelLinking="true"
+ 				PrecompiledHeaderFile=".\Release/wiiuse.pch"
+ 				AssemblerListingLocation=".\Release/"
+ 				ObjectFile=".\Release/"
+ 				ProgramDataBaseFileName=".\Release/"
+ 				WarningLevel="4"
+ 				SuppressStartupBanner="true"
+ 				CallingConvention="0"
+ 				CompileAs="1"
+ 			/>
+ 			<Tool
+ 				Name="VCManagedResourceCompilerTool"
+ 			/>
+ 			<Tool
+ 				Name="VCResourceCompilerTool"
+ 				PreprocessorDefinitions="NDEBUG"
+ 				Culture="1033"
+ 			/>
+ 			<Tool
+ 				Name="VCPreLinkEventTool"
+ 			/>
+ 			<Tool
+ 				Name="VCLinkerTool"
+ 				AdditionalDependencies="odbc32.lib odbccp32.lib Ws2_32.lib hid.lib setupapi.lib"
+ 				OutputFile=".\Release/wiiuse.dll"
+ 				LinkIncremental="1"
+ 				SuppressStartupBanner="true"
+ 				ProgramDatabaseFile=".\Release/wiiuse.pdb"
+ 				RandomizedBaseAddress="1"
+ 				DataExecutionPrevention="0"
+ 				ImportLibrary=".\Release/wiiuse.lib"
+ 				TargetMachine="1"
+ 			/>
+ 			<Tool
+ 				Name="VCALinkTool"
+ 			/>
+ 			<Tool
+ 				Name="VCManifestTool"
+ 			/>
+ 			<Tool
+ 				Name="VCXDCMakeTool"
+ 			/>
+ 			<Tool
+ 				Name="VCBscMakeTool"
+ 				SuppressStartupBanner="true"
+ 				OutputFile=".\Release/wiiuse.bsc"
+ 			/>
+ 			<Tool
+ 				Name="VCFxCopTool"
+ 			/>
+ 			<Tool
+ 				Name="VCAppVerifierTool"
+ 			/>
+ 			<Tool
+ 				Name="VCPostBuildEventTool"
+ 			/>
+ 		</Configuration>
+ 		<Configuration
+ 			Name="Debug|Win32"
+ 			OutputDirectory=".\Debug"
+ 			IntermediateDirectory=".\Debug"
+ 			ConfigurationType="2"
+ 			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+ 			UseOfMFC="0"
+ 			ATLMinimizesCRunTimeLibraryUsage="false"
+ 			CharacterSet="2"
+ 			>
+ 			<Tool
+ 				Name="VCPreBuildEventTool"
+ 			/>
+ 			<Tool
+ 				Name="VCCustomBuildTool"
+ 			/>
+ 			<Tool
+ 				Name="VCXMLDataGeneratorTool"
+ 			/>
+ 			<Tool
+ 				Name="VCWebServiceProxyGeneratorTool"
+ 			/>
+ 			<Tool
+ 				Name="VCMIDLTool"
+ 				PreprocessorDefinitions="_DEBUG"
+ 				MkTypLibCompatible="true"
+ 				SuppressStartupBanner="true"
+ 				TargetEnvironment="1"
+ 				TypeLibraryName=".\Debug/wiiuse.tlb"
+ 				HeaderFileName=""
+ 			/>
+ 			<Tool
+ 				Name="VCCLCompilerTool"
+ 				Optimization="0"
+ 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;WIIUSE_EXPORTS;WITH_WIIUSE_DEBUG"
+ 				MinimalRebuild="true"
+ 				BasicRuntimeChecks="3"
+ 				RuntimeLibrary="1"
+ 				PrecompiledHeaderFile=".\Debug/wiiuse.pch"
+ 				AssemblerListingLocation=".\Debug/"
+ 				ObjectFile=".\Debug/"
+ 				ProgramDataBaseFileName=".\Debug/"
+ 				WarningLevel="3"
+ 				SuppressStartupBanner="true"
+ 				DebugInformationFormat="4"
+ 			/>
+ 			<Tool
+ 				Name="VCManagedResourceCompilerTool"
+ 			/>
+ 			<Tool
+ 				Name="VCResourceCompilerTool"
+ 				PreprocessorDefinitions="_DEBUG"
+ 				Culture="1033"
+ 			/>
+ 			<Tool
+ 				Name="VCPreLinkEventTool"
+ 			/>
+ 			<Tool
+ 				Name="VCLinkerTool"
+ 				AdditionalDependencies="odbc32.lib odbccp32.lib Ws2_32.lib hid.lib setupapi.lib"
+ 				OutputFile=".\Debug/wiiuse.dll"
+ 				LinkIncremental="2"
+ 				SuppressStartupBanner="true"
+ 				GenerateDebugInformation="true"
+ 				ProgramDatabaseFile=".\Debug/wiiuse.pdb"
+ 				RandomizedBaseAddress="1"
+ 				DataExecutionPrevention="0"
+ 				ImportLibrary=".\Debug/wiiuse.lib"
+ 				TargetMachine="1"
+ 			/>
+ 			<Tool
+ 				Name="VCALinkTool"
+ 			/>
+ 			<Tool
+ 				Name="VCManifestTool"
+ 			/>
+ 			<Tool
+ 				Name="VCXDCMakeTool"
+ 			/>
+ 			<Tool
+ 				Name="VCBscMakeTool"
+ 				SuppressStartupBanner="true"
+ 				OutputFile=".\Debug/wiiuse.bsc"
+ 			/>
+ 			<Tool
+ 				Name="VCFxCopTool"
+ 			/>
+ 			<Tool
+ 				Name="VCAppVerifierTool"
+ 			/>
+ 			<Tool
+ 				Name="VCPostBuildEventTool"
+ 			/>
+ 		</Configuration>
+ 	</Configurations>
+ 	<References>
+ 	</References>
+ 	<Files>
+ 		<Filter
+ 			Name="Source Files"
+ 			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+ 			>
+ 			<File
+ 				RelativePath="..\classic.c"
+ 				>
+ 				<FileConfiguration
+ 					Name="Release|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 				<FileConfiguration
+ 					Name="Debug|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 			</File>
+ 			<File
+ 				RelativePath="..\dynamics.c"
+ 				>
+ 				<FileConfiguration
+ 					Name="Release|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 				<FileConfiguration
+ 					Name="Debug|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 			</File>
+ 			<File
+ 				RelativePath="..\events.c"
+ 				>
+ 				<FileConfiguration
+ 					Name="Release|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 				<FileConfiguration
+ 					Name="Debug|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 			</File>
+ 			<File
+ 				RelativePath="..\guitar_hero_3.c"
+ 				>
+ 				<FileConfiguration
+ 					Name="Release|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 				<FileConfiguration
+ 					Name="Debug|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 			</File>
+ 			<File
+ 				RelativePath="..\io.c"
+ 				>
+ 				<FileConfiguration
+ 					Name="Release|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 				<FileConfiguration
+ 					Name="Debug|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 			</File>
+ 			<File
+ 				RelativePath="..\io_nix.c"
+ 				>
+ 				<FileConfiguration
+ 					Name="Release|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 				<FileConfiguration
+ 					Name="Debug|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 			</File>
+ 			<File
+ 				RelativePath="..\io_win.c"
+ 				>
+ 				<FileConfiguration
+ 					Name="Release|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 				<FileConfiguration
+ 					Name="Debug|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 			</File>
+ 			<File
+ 				RelativePath="..\ir.c"
+ 				>
+ 				<FileConfiguration
+ 					Name="Release|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 				<FileConfiguration
+ 					Name="Debug|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 			</File>
+ 			<File
+ 				RelativePath="..\nunchuk.c"
+ 				>
+ 				<FileConfiguration
+ 					Name="Release|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 				<FileConfiguration
+ 					Name="Debug|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 			</File>
+ 			<File
+ 				RelativePath="..\wiiboard.c"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\wiiuse.c"
+ 				>
+ 				<FileConfiguration
+ 					Name="Release|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 				<FileConfiguration
+ 					Name="Debug|Win32"
+ 					>
+ 					<Tool
+ 						Name="VCCLCompilerTool"
+ 						PreprocessorDefinitions=""
+ 					/>
+ 				</FileConfiguration>
+ 			</File>
+ 		</Filter>
+ 		<Filter
+ 			Name="Header Files"
+ 			Filter="h;hpp;hxx;hm;inl"
+ 			>
+ 			<File
+ 				RelativePath="..\classic.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\definitions.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\dynamics.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\events.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\guitar_hero_3.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\io.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\ir.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\nunchuk.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\os.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\wiiboard.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\wiiuse.h"
+ 				>
+ 			</File>
+ 			<File
+ 				RelativePath="..\wiiuse_internal.h"
+ 				>
+ 			</File>
+ 		</Filter>
+ 		<Filter
+ 			Name="Resource Files"
+ 			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+ 			>
+ 			<File
+ 				RelativePath="..\..\CHANGELOG"
+ 				>
+ 			</File>
+ 		</Filter>
+ 	</Files>
+ 	<Globals>
+ 	</Globals>
+ </VisualStudioProject>
diff -crN wiiuse_v0.12/src/msvc/wiiuse.vcxproj wiiuse_v0.12_bb_final/src/msvc/wiiuse.vcxproj
*** wiiuse_v0.12/src/msvc/wiiuse.vcxproj	1970-01-01 01:00:00.000000000 +0100
--- wiiuse_v0.12_bb_final/src/msvc/wiiuse.vcxproj	2010-05-18 17:22:52.000000000 +0200
***************
*** 0 ****
--- 1,203 ----
+ ﻿<?xml version="1.0" encoding="utf-8"?>
+ <Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+   <ItemGroup Label="ProjectConfigurations">
+     <ProjectConfiguration Include="Debug|Win32">
+       <Configuration>Debug</Configuration>
+       <Platform>Win32</Platform>
+     </ProjectConfiguration>
+     <ProjectConfiguration Include="Release|Win32">
+       <Configuration>Release</Configuration>
+       <Platform>Win32</Platform>
+     </ProjectConfiguration>
+   </ItemGroup>
+   <PropertyGroup Label="Globals">
+     <ProjectGuid>{7E5ABF18-4A57-4ECA-BF8A-AA3C41165CBB}</ProjectGuid>
+     <RootNamespace>wiiuse</RootNamespace>
+   </PropertyGroup>
+   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+     <ConfigurationType>DynamicLibrary</ConfigurationType>
+     <UseOfMfc>false</UseOfMfc>
+     <CharacterSet>MultiByte</CharacterSet>
+   </PropertyGroup>
+   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+     <ConfigurationType>DynamicLibrary</ConfigurationType>
+     <UseOfMfc>false</UseOfMfc>
+     <CharacterSet>MultiByte</CharacterSet>
+   </PropertyGroup>
+   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+   <ImportGroup Label="ExtensionSettings">
+   </ImportGroup>
+   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+     <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+   </ImportGroup>
+   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+     <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+   </ImportGroup>
+   <PropertyGroup Label="UserMacros" />
+   <PropertyGroup>
+     <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+     <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.\Release\</OutDir>
+     <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.\Release\</IntDir>
+     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+     <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">.\Debug\</OutDir>
+     <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">.\Debug\</IntDir>
+     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+   </PropertyGroup>
+   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+     <Midl>
+       <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <MkTypLibCompatible>true</MkTypLibCompatible>
+       <SuppressStartupBanner>true</SuppressStartupBanner>
+       <TargetEnvironment>Win32</TargetEnvironment>
+       <TypeLibraryName>.\Release/wiiuse.tlb</TypeLibraryName>
+       <HeaderFileName>
+       </HeaderFileName>
+     </Midl>
+     <ClCompile>
+       <Optimization>MaxSpeed</Optimization>
+       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+       <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;WIIUSE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <StringPooling>true</StringPooling>
+       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+       <FunctionLevelLinking>true</FunctionLevelLinking>
+       <PrecompiledHeaderOutputFile>.\Release/wiiuse.pch</PrecompiledHeaderOutputFile>
+       <AssemblerListingLocation>.\Release/</AssemblerListingLocation>
+       <ObjectFileName>.\Release/</ObjectFileName>
+       <ProgramDataBaseFileName>.\Release/</ProgramDataBaseFileName>
+       <WarningLevel>Level4</WarningLevel>
+       <SuppressStartupBanner>true</SuppressStartupBanner>
+       <CallingConvention>Cdecl</CallingConvention>
+       <CompileAs>CompileAsC</CompileAs>
+     </ClCompile>
+     <ResourceCompile>
+       <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <Culture>0x0409</Culture>
+     </ResourceCompile>
+     <Link>
+       <AdditionalDependencies>odbc32.lib;odbccp32.lib;Ws2_32.lib;hid.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+       <OutputFile>.\Release/wiiuse.dll</OutputFile>
+       <SuppressStartupBanner>true</SuppressStartupBanner>
+       <ProgramDatabaseFile>.\Release/wiiuse.pdb</ProgramDatabaseFile>
+       <RandomizedBaseAddress>false</RandomizedBaseAddress>
+       <DataExecutionPrevention>
+       </DataExecutionPrevention>
+       <ImportLibrary>.\Release/wiiuse.lib</ImportLibrary>
+       <TargetMachine>MachineX86</TargetMachine>
+     </Link>
+     <Bscmake>
+       <SuppressStartupBanner>true</SuppressStartupBanner>
+       <OutputFile>.\Release/wiiuse.bsc</OutputFile>
+     </Bscmake>
+   </ItemDefinitionGroup>
+   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+     <Midl>
+       <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <MkTypLibCompatible>true</MkTypLibCompatible>
+       <SuppressStartupBanner>true</SuppressStartupBanner>
+       <TargetEnvironment>Win32</TargetEnvironment>
+       <TypeLibraryName>.\Debug/wiiuse.tlb</TypeLibraryName>
+       <HeaderFileName>
+       </HeaderFileName>
+     </Midl>
+     <ClCompile>
+       <Optimization>Disabled</Optimization>
+       <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;WIIUSE_EXPORTS;WITH_WIIUSE_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <MinimalRebuild>true</MinimalRebuild>
+       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+       <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+       <PrecompiledHeaderOutputFile>.\Debug/wiiuse.pch</PrecompiledHeaderOutputFile>
+       <AssemblerListingLocation>.\Debug/</AssemblerListingLocation>
+       <ObjectFileName>.\Debug/</ObjectFileName>
+       <ProgramDataBaseFileName>.\Debug/</ProgramDataBaseFileName>
+       <WarningLevel>Level3</WarningLevel>
+       <SuppressStartupBanner>true</SuppressStartupBanner>
+       <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+     </ClCompile>
+     <ResourceCompile>
+       <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <Culture>0x0409</Culture>
+     </ResourceCompile>
+     <Link>
+       <AdditionalDependencies>odbc32.lib;odbccp32.lib;Ws2_32.lib;hid.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+       <OutputFile>.\Debug/wiiuse.dll</OutputFile>
+       <SuppressStartupBanner>true</SuppressStartupBanner>
+       <GenerateDebugInformation>true</GenerateDebugInformation>
+       <ProgramDatabaseFile>.\Debug/wiiuse.pdb</ProgramDatabaseFile>
+       <RandomizedBaseAddress>false</RandomizedBaseAddress>
+       <DataExecutionPrevention>
+       </DataExecutionPrevention>
+       <ImportLibrary>.\Debug/wiiuse.lib</ImportLibrary>
+       <TargetMachine>MachineX86</TargetMachine>
+     </Link>
+     <Bscmake>
+       <SuppressStartupBanner>true</SuppressStartupBanner>
+       <OutputFile>.\Debug/wiiuse.bsc</OutputFile>
+     </Bscmake>
+   </ItemDefinitionGroup>
+   <ItemGroup>
+     <ClCompile Include="..\classic.c">
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+     </ClCompile>
+     <ClCompile Include="..\dynamics.c">
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+     </ClCompile>
+     <ClCompile Include="..\events.c">
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+     </ClCompile>
+     <ClCompile Include="..\guitar_hero_3.c">
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+     </ClCompile>
+     <ClCompile Include="..\io.c">
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+     </ClCompile>
+     <ClCompile Include="..\io_nix.c">
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+     </ClCompile>
+     <ClCompile Include="..\io_win.c">
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+     </ClCompile>
+     <ClCompile Include="..\ir.c">
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+     </ClCompile>
+     <ClCompile Include="..\nunchuk.c">
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+     </ClCompile>
+     <ClCompile Include="..\wiiboard.c" />
+     <ClCompile Include="..\wiiuse.c">
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
+     </ClCompile>
+   </ItemGroup>
+   <ItemGroup>
+     <ClInclude Include="..\classic.h" />
+     <ClInclude Include="..\definitions.h" />
+     <ClInclude Include="..\dynamics.h" />
+     <ClInclude Include="..\events.h" />
+     <ClInclude Include="..\guitar_hero_3.h" />
+     <ClInclude Include="..\io.h" />
+     <ClInclude Include="..\ir.h" />
+     <ClInclude Include="..\nunchuk.h" />
+     <ClInclude Include="..\os.h" />
+     <ClInclude Include="..\wiiboard.h" />
+     <ClInclude Include="..\wiiuse.h" />
+     <ClInclude Include="..\wiiuse_internal.h" />
+   </ItemGroup>
+   <ItemGroup>
+     <None Include="..\..\CHANGELOG" />
+   </ItemGroup>
+   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+   <ImportGroup Label="ExtensionTargets">
+   </ImportGroup>
+ </Project>
\ No newline at end of file
diff -crN wiiuse_v0.12/src/msvc/wiiuse.vcxproj.filters wiiuse_v0.12_bb_final/src/msvc/wiiuse.vcxproj.filters
*** wiiuse_v0.12/src/msvc/wiiuse.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
--- wiiuse_v0.12_bb_final/src/msvc/wiiuse.vcxproj.filters	2010-05-18 17:22:52.000000000 +0200
***************
*** 0 ****
--- 1,95 ----
+ ﻿<?xml version="1.0" encoding="utf-8"?>
+ <Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+   <ItemGroup>
+     <Filter Include="Source Files">
+       <UniqueIdentifier>{0ca403ab-cf23-4f12-b213-72c30fede23f}</UniqueIdentifier>
+       <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
+     </Filter>
+     <Filter Include="Header Files">
+       <UniqueIdentifier>{3730e9d7-4c38-44f5-a4bd-97d6c0f43124}</UniqueIdentifier>
+       <Extensions>h;hpp;hxx;hm;inl</Extensions>
+     </Filter>
+     <Filter Include="Resource Files">
+       <UniqueIdentifier>{040eaf6f-a8ba-4e52-8dae-be27f948ec40}</UniqueIdentifier>
+       <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
+     </Filter>
+   </ItemGroup>
+   <ItemGroup>
+     <ClCompile Include="..\classic.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+     <ClCompile Include="..\dynamics.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+     <ClCompile Include="..\events.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+     <ClCompile Include="..\guitar_hero_3.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+     <ClCompile Include="..\io.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+     <ClCompile Include="..\io_nix.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+     <ClCompile Include="..\io_win.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+     <ClCompile Include="..\ir.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+     <ClCompile Include="..\nunchuk.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+     <ClCompile Include="..\wiiboard.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+     <ClCompile Include="..\wiiuse.c">
+       <Filter>Source Files</Filter>
+     </ClCompile>
+   </ItemGroup>
+   <ItemGroup>
+     <ClInclude Include="..\classic.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\definitions.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\dynamics.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\events.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\guitar_hero_3.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\io.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\ir.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\nunchuk.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\os.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\wiiboard.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\wiiuse.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+     <ClInclude Include="..\wiiuse_internal.h">
+       <Filter>Header Files</Filter>
+     </ClInclude>
+   </ItemGroup>
+   <ItemGroup>
+     <None Include="..\..\CHANGELOG">
+       <Filter>Resource Files</Filter>
+     </None>
+   </ItemGroup>
+ </Project>
\ No newline at end of file
diff -crN wiiuse_v0.12/src/nunchuk.c wiiuse_v0.12_bb_final/src/nunchuk.c
*** wiiuse_v0.12/src/nunchuk.c	2008-03-28 00:04:25.000000000 +0100
--- wiiuse_v0.12_bb_final/src/nunchuk.c	2009-10-07 17:47:46.000000000 +0200
***************
*** 1,71 ****
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Nunchuk expansion device.
!  */
! 
! #include <stdio.h>
! #include <stdlib.h>
! #include <math.h>
! 
! #include "definitions.h"
! #include "wiiuse_internal.h"
! #include "dynamics.h"
! #include "events.h"
! #include "nunchuk.h"
! 
! static void nunchuk_pressed_buttons(struct nunchuk_t* nc, byte now);
! 
! /**
!  *	@brief Handle the handshake data from the nunchuk.
!  *
!  *	@param nc		A pointer to a nunchuk_t structure.
!  *	@param data		The data read in from the device.
!  *	@param len		The length of the data block, in bytes.
!  *
!  *	@return	Returns 1 if handshake was successful, 0 if not.
!  */
! int nunchuk_handshake(struct wiimote_t* wm, struct nunchuk_t* nc, byte* data, unsigned short len) {
  	int i;
  	int offset = 0;
  
! 	nc->btns = 0;
! 	nc->btns_held = 0;
! 	nc->btns_released = 0;
! 
! 	/* set the smoothing to the same as the wiimote */
! 	nc->flags = &wm->flags;
! 	nc->accel_calib.st_alpha = wm->accel_calib.st_alpha;
! 
! 	/* decrypt data */
! 	for (i = 0; i < len; ++i)
  		data[i] = (data[i] ^ 0x17) + 0x17;
  
  	if (data[offset] == 0xFF) {
--- 1,71 ----
! /*
!  *	wiiuse
!  *
!  *	Written By:
!  *		Michael Laforest	< para >
!  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
!  *
!  *	Copyright 2006-2007
!  *
!  *	This file is part of wiiuse.
!  *
!  *	This program is free software; you can redistribute it and/or modify
!  *	it under the terms of the GNU General Public License as published by
!  *	the Free Software Foundation; either version 3 of the License, or
!  *	(at your option) any later version.
!  *
!  *	This program is distributed in the hope that it will be useful,
!  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
!  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  *	GNU General Public License for more details.
!  *
!  *	You should have received a copy of the GNU General Public License
!  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
!  *
!  *	$Header$
!  *
!  */
! 
! /**
!  *	@file
!  *	@brief Nunchuk expansion device.
!  */
! 
! #include <stdio.h>
! #include <stdlib.h>
! #include <math.h>
! 
! #include "definitions.h"
! #include "wiiuse_internal.h"
! #include "dynamics.h"
! #include "events.h"
! #include "nunchuk.h"
! 
! static void nunchuk_pressed_buttons(struct nunchuk_t* nc, byte now);
! 
! /**
!  *	@brief Handle the handshake data from the nunchuk.
!  *
!  *	@param nc		A pointer to a nunchuk_t structure.
!  *	@param data		The data read in from the device.
!  *	@param len		The length of the data block, in bytes.
!  *
!  *	@return	Returns 1 if handshake was successful, 0 if not.
!  */
! int nunchuk_handshake(struct wiimote_t* wm, struct nunchuk_t* nc, byte* data, unsigned short len) {
  	int i;
  	int offset = 0;
  
! 	nc->btns = 0;
! 	nc->btns_held = 0;
! 	nc->btns_released = 0;
! 
! 	/* set the smoothing to the same as the wiimote */
! 	nc->flags = &wm->flags;
! 	nc->accel_calib.st_alpha = wm->accel_calib.st_alpha;
! 
! 	/* decrypt data */
! 	for (i = 0; i < len; ++i)
  		data[i] = (data[i] ^ 0x17) + 0x17;
  
  	if (data[offset] == 0xFF) {
***************
*** 89,210 ****
  			return 0;
  		} else
  			offset += 16;
! 	}
! 
! 	nc->accel_calib.cal_zero.x = data[offset + 0];
! 	nc->accel_calib.cal_zero.y = data[offset + 1];
! 	nc->accel_calib.cal_zero.z = data[offset + 2];
! 	nc->accel_calib.cal_g.x = data[offset + 4];
! 	nc->accel_calib.cal_g.y = data[offset + 5];
! 	nc->accel_calib.cal_g.z = data[offset + 6];
! 	nc->js.max.x = data[offset + 8];
! 	nc->js.min.x = data[offset + 9];
! 	nc->js.center.x = data[offset + 10];
! 	nc->js.max.y = data[offset + 11];
! 	nc->js.min.y = data[offset + 12];
! 	nc->js.center.y = data[offset + 13];
! 
! 	/* default the thresholds to the same as the wiimote */
! 	nc->orient_threshold = wm->orient_threshold;
! 	nc->accel_threshold = wm->accel_threshold;
! 
  	/* handshake done */
  	wm->exp.type = EXP_NUNCHUK;
  
  	#ifdef WIN32
  	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
! 	#endif
! 
! 	return 1;
! }
! 
! 
! /**
!  *	@brief The nunchuk disconnected.
!  *
!  *	@param nc		A pointer to a nunchuk_t structure.
!  */
! void nunchuk_disconnected(struct nunchuk_t* nc) {
! 	memset(nc, 0, sizeof(struct nunchuk_t));
! }
! 
! 
! 
! /**
!  *	@brief Handle nunchuk event.
!  *
!  *	@param nc		A pointer to a nunchuk_t structure.
!  *	@param msg		The message specified in the event packet.
!  */
! void nunchuk_event(struct nunchuk_t* nc, byte* msg) {
! 	int i;
! 
! 	/* decrypt data */
! 	for (i = 0; i < 6; ++i)
! 		msg[i] = (msg[i] ^ 0x17) + 0x17;
! 
! 	/* get button states */
! 	nunchuk_pressed_buttons(nc, msg[5]);
! 
! 	/* calculate joystick state */
! 	calc_joystick_state(&nc->js, msg[0], msg[1]);
! 
! 	/* calculate orientation */
! 	nc->accel.x = msg[2];
! 	nc->accel.y = msg[3];
! 	nc->accel.z = msg[4];
! 
! 	calculate_orientation(&nc->accel_calib, &nc->accel, &nc->orient, NUNCHUK_IS_FLAG_SET(nc, WIIUSE_SMOOTHING));
! 	calculate_gforce(&nc->accel_calib, &nc->accel, &nc->gforce);
! }
! 
! 
! /**
!  *	@brief Find what buttons are pressed.
!  *
!  *	@param nc		Pointer to a nunchuk_t structure.
!  *	@param msg		The message byte specified in the event packet.
!  */
! static void nunchuk_pressed_buttons(struct nunchuk_t* nc, byte now) {
! 	/* message is inverted (0 is active, 1 is inactive) */
! 	now = ~now & NUNCHUK_BUTTON_ALL;
! 
! 	/* pressed now & were pressed, then held */
! 	nc->btns_held = (now & nc->btns);
! 
! 	/* were pressed or were held & not pressed now, then released */
! 	nc->btns_released = ((nc->btns | nc->btns_held) & ~now);
! 
! 	/* buttons pressed now */
! 	nc->btns = now;
! }
! 
! 
! /**
!  *	@brief	Set the orientation event threshold for the nunchuk.
!  *
!  *	@param wm			Pointer to a wiimote_t structure with a nunchuk attached.
!  *	@param threshold	The decimal place that should be considered a significant change.
!  *
!  *	See wiiuse_set_orient_threshold() for details.
!  */
! void wiiuse_set_nunchuk_orient_threshold(struct wiimote_t* wm, float threshold) {
! 	if (!wm)	return;
! 
! 	wm->exp.nunchuk.orient_threshold = threshold;
! }
! 
! 
! /**
!  *	@brief	Set the accelerometer event threshold for the nunchuk.
!  *
!  *	@param wm			Pointer to a wiimote_t structure with a nunchuk attached.
!  *	@param threshold	The decimal place that should be considered a significant change.
!  *
!  *	See wiiuse_set_orient_threshold() for details.
!  */
! void wiiuse_set_nunchuk_accel_threshold(struct wiimote_t* wm, int threshold) {
! 	if (!wm)	return;
! 
! 	wm->exp.nunchuk.accel_threshold = threshold;
! }
--- 89,210 ----
  			return 0;
  		} else
  			offset += 16;
! 	}
! 
! 	nc->accel_calib.cal_zero.x = data[offset + 0];
! 	nc->accel_calib.cal_zero.y = data[offset + 1];
! 	nc->accel_calib.cal_zero.z = data[offset + 2];
! 	nc->accel_calib.cal_g.x = data[offset + 4];
! 	nc->accel_calib.cal_g.y = data[offset + 5];
! 	nc->accel_calib.cal_g.z = data[offset + 6];
! 	nc->js.max.x = data[offset + 8];
! 	nc->js.min.x = data[offset + 9];
! 	nc->js.center.x = data[offset + 10];
! 	nc->js.max.y = data[offset + 11];
! 	nc->js.min.y = data[offset + 12];
! 	nc->js.center.y = data[offset + 13];
! 
! 	/* default the thresholds to the same as the wiimote */
! 	nc->orient_threshold = wm->orient_threshold;
! 	nc->accel_threshold = wm->accel_threshold;
! 
  	/* handshake done */
  	wm->exp.type = EXP_NUNCHUK;
  
  	#ifdef WIN32
  	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
! 	#endif
! 
! 	return 1;
! }
! 
! 
! /**
!  *	@brief The nunchuk disconnected.
!  *
!  *	@param nc		A pointer to a nunchuk_t structure.
!  */
! void nunchuk_disconnected(struct nunchuk_t* nc) {
! 	memset(nc, 0, sizeof(struct nunchuk_t));
! }
! 
! 
! 
! /**
!  *	@brief Handle nunchuk event.
!  *
!  *	@param nc		A pointer to a nunchuk_t structure.
!  *	@param msg		The message specified in the event packet.
!  */
! void nunchuk_event(struct nunchuk_t* nc, byte* msg) {
! 	int i;
! 
! 	/* decrypt data */
! 	for (i = 0; i < 6; ++i)
! 		msg[i] = (msg[i] ^ 0x17) + 0x17;
! 
! 	/* get button states */
! 	nunchuk_pressed_buttons(nc, msg[5]);
! 
! 	/* calculate joystick state */
! 	calc_joystick_state(&nc->js, msg[0], msg[1]);
! 
! 	/* calculate orientation */
! 	nc->accel.x = msg[2];
! 	nc->accel.y = msg[3];
! 	nc->accel.z = msg[4];
! 
! 	calculate_orientation(&nc->accel_calib, &nc->accel, &nc->orient, NUNCHUK_IS_FLAG_SET(nc, WIIUSE_SMOOTHING));
! 	calculate_gforce(&nc->accel_calib, &nc->accel, &nc->gforce);
! }
! 
! 
! /**
!  *	@brief Find what buttons are pressed.
!  *
!  *	@param nc		Pointer to a nunchuk_t structure.
!  *	@param msg		The message byte specified in the event packet.
!  */
! static void nunchuk_pressed_buttons(struct nunchuk_t* nc, byte now) {
! 	/* message is inverted (0 is active, 1 is inactive) */
! 	now = ~now & NUNCHUK_BUTTON_ALL;
! 
! 	/* pressed now & were pressed, then held */
! 	nc->btns_held = (now & nc->btns);
! 
! 	/* were pressed or were held & not pressed now, then released */
! 	nc->btns_released = ((nc->btns | nc->btns_held) & ~now);
! 
! 	/* buttons pressed now */
! 	nc->btns = now;
! }
! 
! 
! /**
!  *	@brief	Set the orientation event threshold for the nunchuk.
!  *
!  *	@param wm			Pointer to a wiimote_t structure with a nunchuk attached.
!  *	@param threshold	The decimal place that should be considered a significant change.
!  *
!  *	See wiiuse_set_orient_threshold() for details.
!  */
! void wiiuse_set_nunchuk_orient_threshold(struct wiimote_t* wm, float threshold) {
! 	if (!wm)	return;
! 
! 	wm->exp.nunchuk.orient_threshold = threshold;
! }
! 
! 
! /**
!  *	@brief	Set the accelerometer event threshold for the nunchuk.
!  *
!  *	@param wm			Pointer to a wiimote_t structure with a nunchuk attached.
!  *	@param threshold	The decimal place that should be considered a significant change.
!  *
!  *	See wiiuse_set_orient_threshold() for details.
!  */
! void wiiuse_set_nunchuk_accel_threshold(struct wiimote_t* wm, int threshold) {
! 	if (!wm)	return;
! 
! 	wm->exp.nunchuk.accel_threshold = threshold;
! }
diff -crN wiiuse_v0.12/src/wiiboard.c wiiuse_v0.12_bb_final/src/wiiboard.c
*** wiiuse_v0.12/src/wiiboard.c	1970-01-01 01:00:00.000000000 +0100
--- wiiuse_v0.12_bb_final/src/wiiboard.c	2010-05-20 02:12:26.000000000 +0200
***************
*** 0 ****
--- 1,242 ----
+ /*
+  *	wiiuse
+  *
+  *	Written By:
+  *		Michael Laforest	< para >
+  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
+  *
+  *	Copyright 2006-2007
+  *
+  *	This file is part of wiiuse.
+  *
+  *	This program is free software; you can redistribute it and/or modify
+  *	it under the terms of the GNU General Public License as published by
+  *	the Free Software Foundation; either version 3 of the License, or
+  *	(at your option) any later version.
+  *
+  *	This program is distributed in the hope that it will be useful,
+  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *	GNU General Public License for more details.
+  *
+  *	You should have received a copy of the GNU General Public License
+  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  *	$Header$
+  *
+  */
+ 
+ /**
+  *	@file
+  *	@brief Wii Fit Balance Board device.
+  */
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <math.h>
+ 
+ #ifdef WIN32
+ 	#include <Winsock2.h>
+ #endif
+ 
+ #include "definitions.h"
+ #include "wiiuse_internal.h"
+ #include "dynamics.h"
+ #include "events.h"
+ #include "wiiboard.h"
+ /*
+ static short big_to_lil(unsigned short num)
+ {
+ 	short ret = num;
+ 	char *bret = (char*)&ret;
+ 	char tmp = bret[1];
+ 	bret[1] = bret[0];
+ 	bret[0] = tmp;
+ 	return ret;
+ }
+ */
+ /**
+  *	@brief Handle the handshake data from the balance board.
+  *
+  *	@param wb		A pointer to a wii_board_t structure.
+  *	@param data		The data read in from the device.
+  *	@param len		The length of the data block, in bytes.
+  *
+  *	@return	Returns 1 if handshake was successful, 0 if not.
+  */
+ 
+ int wii_board_handshake(struct wiimote_t* wm, struct wii_board_t* wb, byte* data, unsigned short len) {
+ 	int i;
+ 	int offset = 0;
+ 	
+ 	/* decrypt data */
+ 	for (i = 0; i < len; ++i)
+ 		data[i] = (data[i] ^ 0x17) + 0x17;
+ 
+ 	if (data[offset] == 0xFF) {
+ 		/*
+ 		 *	Sometimes the data returned here is not correct.
+ 		 *	This might happen because the wiimote is lagging
+ 		 *	behind our initialization sequence.
+ 		 *	To fix this just request the handshake again.
+ 		 *
+ 		 *	Other times it's just the first 16 bytes are 0xFF,
+ 		 *	but since the next 16 bytes are the same, just use
+ 		 *	those.
+ 		 */
+ 		if (data[offset + 16] == 0xFF) {
+ 			/* get the calibration data */
+ 			byte* handshake_buf = malloc(EXP_HANDSHAKE_LEN * sizeof(byte));
+ 
+ 			WIIUSE_DEBUG("Balance board handshake appears invalid, trying again.");
+ 			wiiuse_read_data_cb(wm, handshake_expansion, handshake_buf, WM_EXP_MEM_CALIBR, EXP_HANDSHAKE_LEN);
+ 
+ 			return 0;
+ 		} else
+ 			offset += 16;
+ 	}
+ 	
+ 	/* board initial data */
+ 	wb->hs[0].tr = (data[4 + offset] << 8) | data[5 + offset];
+ 	wb->hs[0].br = (data[6 + offset] << 8) | data[7 + offset];
+ 	wb->hs[0].tl = (data[8 + offset] << 8) | data[9 + offset];
+ 	wb->hs[0].bl = (data[10 + offset] << 8) | data[11 + offset];
+ 
+ 	wb->hs[1].tr = (data[12 + offset] << 8) | data[13 + offset];
+ 	wb->hs[1].br = (data[14 + offset] << 8) | data[15 + offset];
+ 	wb->hs[1].tl = (data[16 + offset] << 8) | data[17 + offset];
+ 	wb->hs[1].bl = (data[18 + offset] << 8) | data[19 + offset];
+ 
+ 	wb->hs[2].tr = (data[20 + offset] << 8) | data[21 + offset];
+ 	wb->hs[2].br = (data[22 + offset] << 8) | data[23 + offset];
+ 	wb->hs[2].tl = (data[24 + offset] << 8) | data[25 + offset];
+ 	wb->hs[2].bl = (data[26 + offset] << 8) | data[27 + offset];
+ 	/*
+ 	wb->hs[0].tr = big_to_lil(handshake_short[2]);
+ 	wb->hs[0].br = big_to_lil(handshake_short[3]);
+ 	wb->hs[0].tl = big_to_lil(handshake_short[4]);
+ 	wb->hs[0].bl = big_to_lil(handshake_short[5]);
+ 
+ 	wb->hs[1].tr = big_to_lil(handshake_short[6]);
+ 	wb->hs[1].br = big_to_lil(handshake_short[7]);
+ 	wb->hs[1].tl = big_to_lil(handshake_short[8]);
+ 	wb->hs[1].bl = big_to_lil(handshake_short[9]);
+ 
+ 	wb->hs[2].tr = big_to_lil(handshake_short[10]);
+ 	wb->hs[2].br = big_to_lil(handshake_short[11]);
+ 	wb->hs[2].tl = big_to_lil(handshake_short[12]);
+ 	wb->hs[2].bl = big_to_lil(handshake_short[13]);
+ 	*/
+ 	/* initial calibration */
+ 	wb->cal.tr = wb->hs[0].tr;
+ 	wb->cal.br = wb->hs[0].br;
+ 	wb->cal.tl = wb->hs[0].tl;
+ 	wb->cal.bl = wb->hs[0].bl;
+ 
+ 	/* delta initialization*/
+ 	wb->delta.tr = wb->hs[2].tr - wb->hs[0].tr;
+ 	wb->delta.br = wb->hs[2].br - wb->hs[0].br;
+ 	wb->delta.tl = wb->hs[2].tl - wb->hs[0].tl;
+ 	wb->delta.bl = wb->hs[2].bl - wb->hs[0].bl;
+ 
+ 	/* handshake done */
+ 	wm->exp.type = EXP_WII_BOARD;
+ 
+ 	#ifdef WIN32
+ 	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
+ 	#endif
+ 
+ 	return 1;
+ }
+ 
+ 
+ /**
+  *	@brief The balance board disconnected.
+  *
+  *	@param wb		A pointer to a wii_board_t structure.
+  */
+ void wii_board_disconnected(struct wii_board_t* wb) {
+ 	memset(wb, 0, sizeof(struct wii_board_t));
+ }
+ 
+ /**
+  *	@brief Handle balance board event.
+  *
+  *	@param cc		A pointer to a wii_board_t structure.
+  *	@param msg		The message specified in the event packet.
+  */
+ void wii_board_event(struct wii_board_t* wb, byte* msg) {
+ 	int i;
+ 	
+ 	for (i = 0; i < 8; ++i)
+ 		msg[i] = (msg[i] ^ 0x17) + 0x17;
+ 
+ 	// are the < 0 controls necessary? If yes, also with unencrypted data?
+ 	wb->raw.tr = (msg[0] << 8) | msg[1];
+ 	wb->raw.br = (msg[2] << 8) | msg[3];
+ 	wb->raw.tl = (msg[4] << 8) | msg[5];
+ 	wb->raw.bl = (msg[6] << 8) | msg[7];
+ 
+ 	/*
+ 	short *shmsg = (short*)(msg);
+ 
+ 	wb->raw.tr = big_to_lil(shmsg[0]);
+ 	if(wb->raw.tr < 0)
+ 		wb->raw.tr = wb->cal.tr;
+ 	wb->raw.br = big_to_lil(shmsg[1]);
+ 	if(wb->raw.br < 0)
+ 		wb->raw.br = wb->cal.br;
+ 	wb->raw.tl = big_to_lil(shmsg[2]);
+ 	if(wb->raw.tl < 0)
+ 		wb->raw.tl = wb->cal.tl;
+ 	wb->raw.bl = big_to_lil(shmsg[3]);		
+ 	if(wb->raw.bl < 0)
+ 		wb->raw.bl = wb->cal.bl;
+ 	*/
+ 	/* 
+ 		Interpolate values 
+ 		Calculations from z[A]vo (http://www.wiili.org/index.php/Wii_Balance_Board_PC_Drivers) <-- is dead now :(
+ 	*/
+ 
+ 	wb->norm.tr = (float) (wb->raw.tr - wb->cal.tr)/(wb->delta.tr);
+ 	wb->norm.br = (float) (wb->raw.br - wb->cal.br)/(wb->delta.br);
+ 	wb->norm.tl = (float) (wb->raw.tl - wb->cal.tl)/(wb->delta.tl);
+ 	wb->norm.bl = (float) (wb->raw.bl - wb->cal.bl)/(wb->delta.bl);
+ 
+ 	wb->val.tr = wb->norm.tr * MAX_WB_VAL;
+ 	wb->val.br = wb->norm.br * MAX_WB_VAL;
+ 	wb->val.tl = wb->norm.tl * MAX_WB_VAL;
+ 	wb->val.bl = wb->norm.bl * MAX_WB_VAL;
+ 
+ 	/* calculate weight */
+ 	wb->weight = (wb->val.tr + wb->val.br + wb->val.tl + wb->val.bl) / 4;
+ 
+ 	/* calculate weight position */
+ 	wb->pos.x = ((float) (wb->norm.tr + wb->norm.br) - (wb->norm.tl + wb->norm.bl)) / 2;
+ 	if (abs(wb->pos.x) > 1)
+ 		wb->pos.x = (wb->pos.x > 0) - (wb->pos.x < 0);
+ 	wb->pos.y = ((float) (wb->norm.tl + wb->norm.tr) - (wb->norm.bl + wb->norm.br)) / 2;
+ 	if (abs(wb->pos.y) > 1)
+ 		wb->pos.y = (wb->pos.y > 0) - (wb->pos.y < 0);
+ 
+ 	/* set previous value to actual value */
+ 	wb->prev.tr = wb->raw.tr;
+ 	wb->prev.br = wb->raw.br;
+ 	wb->prev.tl = wb->raw.tl;
+ 	wb->prev.bl = wb->raw.bl;
+ }
+ 
+ /**
+  *	@brief Balance board calibration function (sets to "0" the actual value).
+  *
+  *	@param wm		A pointer to the wiimote_t structure associated to the balance board.
+  */
+ void wiiuse_set_wii_board_calib(struct wiimote_t *wm)
+ {
+ 	if (wm->exp.type == EXP_WII_BOARD) {
+ 		wm->exp.wb.cal.tr = wm->exp.wb.raw.tr;
+ 		wm->exp.wb.cal.tl = wm->exp.wb.raw.tl;
+ 		wm->exp.wb.cal.br = wm->exp.wb.raw.br;
+ 		wm->exp.wb.cal.bl = wm->exp.wb.raw.bl;
+ 	}
+ }
diff -crN wiiuse_v0.12/src/wiiboard.h wiiuse_v0.12_bb_final/src/wiiboard.h
*** wiiuse_v0.12/src/wiiboard.h	1970-01-01 01:00:00.000000000 +0100
--- wiiuse_v0.12_bb_final/src/wiiboard.h	2010-05-19 23:49:42.000000000 +0200
***************
*** 0 ****
--- 1,53 ----
+ /*
+  *	wiiuse
+  *
+  *	Written By:
+  *		Michael Laforest	< para >
+  *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
+  *
+  *	Copyright 2006-2007
+  *
+  *	This file is part of wiiuse.
+  *
+  *	This program is free software; you can redistribute it and/or modify
+  *	it under the terms of the GNU General Public License as published by
+  *	the Free Software Foundation; either version 3 of the License, or
+  *	(at your option) any later version.
+  *
+  *	This program is distributed in the hope that it will be useful,
+  *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *	GNU General Public License for more details.
+  *
+  *	You should have received a copy of the GNU General Public License
+  *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  *	$Header$
+  *
+  */
+ 
+ /**
+  *	@file
+  *	@brief Wii Fit Balance Board device.
+  */
+ 
+ #ifndef WII_BOARD_H_INCLUDED
+ #define WII_BOARD_H_INCLUDED
+ 
+ #include "wiiuse_internal.h"
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ int wii_board_handshake(struct wiimote_t* wm, struct wii_board_t* wb, byte* data, unsigned short len);
+ 
+ void wii_board_disconnected(struct wii_board_t* wb);
+ 
+ void wii_board_event(struct wii_board_t* wb, byte* msg);
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif
diff -crN wiiuse_v0.12/src/wiiuse.c wiiuse_v0.12_bb_final/src/wiiuse.c
*** wiiuse_v0.12/src/wiiuse.c	2008-03-28 00:29:27.000000000 +0100
--- wiiuse_v0.12_bb_final/src/wiiuse.c	2009-10-06 16:55:42.000000000 +0200
***************
*** 360,366 ****
  	req->buf = buffer;
  	req->addr = addr;
  	req->size = len;
! 	req->wait = len;
  	req->dirty = 0;
  	req->next = NULL;
  
--- 360,421 ----
  	req->buf = buffer;
  	req->addr = addr;
  	req->size = len;
! 	req->wait = len;
! 	req->dirty = 0;
! 	req->next = NULL;
! 
! 	/* add this to the request list */
! 	if (!wm->read_req) {
! 		/* root node */
! 		wm->read_req = req;
! 
! 		WIIUSE_DEBUG("Data read request can be sent out immediately.");
! 
! 		/* send the request out immediately */
! 		wiiuse_send_next_pending_read_request(wm);
! 	} else {
! 		struct read_req_t* nptr = wm->read_req;
! 		for (; nptr->next; nptr = nptr->next);
! 		nptr->next = req;
! 
! 		WIIUSE_DEBUG("Added pending data read request.");
! 	}
! 
! 	return 1;
! }
! 
! 
! /**
!  *	@brief	Read data from the wiimote (event version).
!  *
!  *	@param wm		Pointer to a wiimote_t structure.
!  *	@param buffer	An allocated buffer to store the data as it arrives from the wiimote.
!  *					Must be persistent in memory and large enough to hold the data.
!  *	@param addr		The address of wiimote memory to read from.
!  *	@param len		The length of the block to be read.
!  *
!  *	The library can only handle one data read request at a time
!  *	because it must keep track of the buffer and other
!  *	events that are specific to that request.  So if a request
!  *	has already been made, subsequent requests will be added
!  *	to a pending list and be sent out when the previous
!  *	finishes.
!  */
! int wiiuse_read_data(struct wiimote_t* wm, byte* buffer, unsigned int addr, unsigned short len) {
! 	struct read_req_t* req;
! 
! 	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
! 		return 0;
! 	if (!buffer || !len)
! 		return 0;
! 
! 	/* make this request structure */
! 	req = (struct read_req_t*)malloc(sizeof(struct read_req_t));
! 	req->cb = NULL;
! 	req->buf = buffer;
! 	req->addr = addr;
! 	req->size = len;
! 	req->wait = len;
  	req->dirty = 0;
  	req->next = NULL;
  
***************
*** 385,445 ****
  }
  
  
- /**
-  *	@brief	Read data from the wiimote (event version).
-  *
-  *	@param wm		Pointer to a wiimote_t structure.
-  *	@param buffer	An allocated buffer to store the data as it arrives from the wiimote.
-  *					Must be persistent in memory and large enough to hold the data.
-  *	@param addr		The address of wiimote memory to read from.
-  *	@param len		The length of the block to be read.
-  *
-  *	The library can only handle one data read request at a time
-  *	because it must keep track of the buffer and other
-  *	events that are specific to that request.  So if a request
-  *	has already been made, subsequent requests will be added
-  *	to a pending list and be sent out when the previous
-  *	finishes.
-  */
- int wiiuse_read_data(struct wiimote_t* wm, byte* buffer, unsigned int addr, unsigned short len) {
- 	struct read_req_t* req;
- 
- 	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
- 		return 0;
- 	if (!buffer || !len)
- 		return 0;
- 
- 	/* make this request structure */
- 	req = (struct read_req_t*)malloc(sizeof(struct read_req_t));
- 	req->cb = NULL;
- 	req->buf = buffer;
- 	req->addr = addr;
- 	req->size = len;
- 	req->wait = len;
- 	req->dirty = 0;
- 	req->next = NULL;
- 
- 	/* add this to the request list */
- 	if (!wm->read_req) {
- 		/* root node */
- 		wm->read_req = req;
- 
- 		WIIUSE_DEBUG("Data read request can be sent out immediately.");
- 
- 		/* send the request out immediately */
- 		wiiuse_send_next_pending_read_request(wm);
- 	} else {
- 		struct read_req_t* nptr = wm->read_req;
- 		for (; nptr->next; nptr = nptr->next);
- 		nptr->next = req;
- 
- 		WIIUSE_DEBUG("Added pending data read request.");
- 	}
- 
- 	return 1;
- }
- 
- 
  /**
   *	@brief Send the next pending data read request to the wiimote.
   *
--- 440,445 ----
***************
*** 457,467 ****
  		return;
  	if (!wm->read_req)	return;
  
! 	/* skip over dirty ones since they have already been read */
! 	req = wm->read_req;
! 	while (req && req->dirty)
! 		req = req->next;
! 	if (!req)
  		return;
  
  	/* the offset is in big endian */
--- 457,467 ----
  		return;
  	if (!wm->read_req)	return;
  
! 	/* skip over dirty ones since they have already been read */
! 	req = wm->read_req;
! 	while (req && req->dirty)
! 		req = req->next;
! 	if (!req)
  		return;
  
  	/* the offset is in big endian */
diff -crN wiiuse_v0.12/src/wiiuse.h wiiuse_v0.12_bb_final/src/wiiuse.h
*** wiiuse_v0.12/src/wiiuse.h	2008-04-02 01:14:16.000000000 +0200
--- wiiuse_v0.12_bb_final/src/wiiuse.h	2010-05-19 23:50:55.000000000 +0200
***************
*** 128,133 ****
--- 128,134 ----
  #define EXP_NUNCHUK						1
  #define EXP_CLASSIC						2
  #define EXP_GUITAR_HERO_3				3
+ #define EXP_WII_BOARD					4
  
  /* IR correction types */
  typedef enum ir_position_t {
***************
*** 168,190 ****
   *	@param button	The button you are interested in.
   *	@return 1 if the button is pressed, 0 if not.
   */
! #define IS_JUST_PRESSED(dev, button)	(IS_PRESSED(dev, button) && !IS_HELD(dev, button))
! 
! /**
!  *	@brief Return the IR sensitivity level.
!  *	@param wm		Pointer to a wiimote_t structure.
!  *	@param lvl		[out] Pointer to an int that will hold the level setting.
!  *	If no level is set 'lvl' will be set to 0.
!  */
! #define WIIUSE_GET_IR_SENSITIVITY(dev, lvl)									\
! 			do {														\
! 				if ((wm->state & 0x0200) == 0x0200) 		*lvl = 1;	\
! 				else if ((wm->state & 0x0400) == 0x0400) 	*lvl = 2;	\
! 				else if ((wm->state & 0x0800) == 0x0800) 	*lvl = 3;	\
! 				else if ((wm->state & 0x1000) == 0x1000) 	*lvl = 4;	\
! 				else if ((wm->state & 0x2000) == 0x2000) 	*lvl = 5;	\
! 				else									*lvl = 0;		\
! 			} while (0)
  
  #define WIIUSE_USING_ACC(wm)			((wm->state & 0x020) == 0x020)
  #define WIIUSE_USING_EXP(wm)			((wm->state & 0x040) == 0x040)
--- 169,191 ----
   *	@param button	The button you are interested in.
   *	@return 1 if the button is pressed, 0 if not.
   */
! #define IS_JUST_PRESSED(dev, button)	(IS_PRESSED(dev, button) && !IS_HELD(dev, button))
! 
! /**
!  *	@brief Return the IR sensitivity level.
!  *	@param wm		Pointer to a wiimote_t structure.
!  *	@param lvl		[out] Pointer to an int that will hold the level setting.
!  *	If no level is set 'lvl' will be set to 0.
!  */
! #define WIIUSE_GET_IR_SENSITIVITY(dev, lvl)									\
! 			do {														\
! 				if ((wm->state & 0x0200) == 0x0200) 		*lvl = 1;	\
! 				else if ((wm->state & 0x0400) == 0x0400) 	*lvl = 2;	\
! 				else if ((wm->state & 0x0800) == 0x0800) 	*lvl = 3;	\
! 				else if ((wm->state & 0x1000) == 0x1000) 	*lvl = 4;	\
! 				else if ((wm->state & 0x2000) == 0x2000) 	*lvl = 5;	\
! 				else									*lvl = 0;		\
! 			} while (0)
  
  #define WIIUSE_USING_ACC(wm)			((wm->state & 0x020) == 0x020)
  #define WIIUSE_USING_EXP(wm)			((wm->state & 0x040) == 0x040)
***************
*** 242,248 ****
  	byte* buf;					/**< buffer where read data is written							*/
  	unsigned int addr;			/**< the offset that the read started at						*/
  	unsigned short size;		/**< the length of the data read								*/
! 	unsigned short wait;		/**< num bytes still needed to finish read						*/
  	byte dirty;					/**< set to 1 if not using callback and needs to be cleaned up	*/
  
  	struct read_req_t* next;	/**< next read request in the queue								*/
--- 243,249 ----
  	byte* buf;					/**< buffer where read data is written							*/
  	unsigned int addr;			/**< the offset that the read started at						*/
  	unsigned short size;		/**< the length of the data read								*/
! 	unsigned short wait;		/**< num bytes still needed to finish read						*/
  	byte dirty;					/**< set to 1 if not using callback and needs to be cleaned up	*/
  
  	struct read_req_t* next;	/**< next read request in the queue								*/
***************
*** 268,273 ****
--- 269,283 ----
  
  
  /**
+  *	@struct vec2f_t
+  *	@brief Signed x,y float struct.
+  */
+ typedef struct vec2f_t {
+ 	float x, y;
+ } vec2f_t;
+ 
+ 
+ /**
   *	@struct vec3f_t
   *	@brief Signed x,y,z float struct.
   */
***************
*** 409,417 ****
  	byte btns;						/**< what buttons have just been pressed	*/
  	byte btns_held;					/**< what buttons are being held down		*/
  	byte btns_released;				/**< what buttons were just released this	*/
! 
! 	float orient_threshold;			/**< threshold for orient to generate an event */
! 	int accel_threshold;			/**< threshold for accel to generate an event */
  
  	struct vec3b_t accel;			/**< current raw acceleration data			*/
  	struct orient_t orient;			/**< current orientation on each axis		*/
--- 419,427 ----
  	byte btns;						/**< what buttons have just been pressed	*/
  	byte btns_held;					/**< what buttons are being held down		*/
  	byte btns_released;				/**< what buttons were just released this	*/
! 
! 	float orient_threshold;			/**< threshold for orient to generate an event */
! 	int accel_threshold;			/**< threshold for accel to generate an event */
  
  	struct vec3b_t accel;			/**< current raw acceleration data			*/
  	struct orient_t orient;			/**< current orientation on each axis		*/
***************
*** 450,455 ****
--- 460,488 ----
  	struct joystick_t js;			/**< joystick calibration					*/
  } guitar_hero_3_t;
  
+ /*
+ 	Wii board
+ */
+ typedef struct wii_board_4s_t {
+ 	short tl, tr, bl, br;
+ } wii_board_4s_t;
+ 
+ typedef struct wii_board_4f_t {
+ 	float tl, tr, bl, br;
+ } wii_board_4f_t;
+ 
+ typedef struct wii_board_t {
+ 	wii_board_4f_t norm; /* final value, normalized (range -1, 1 !CAN GO OUT THAT RANGE!) */
+ 	wii_board_4f_t val; /* final value, not normalized (range -k, k, k = 136Kg !CAN GO OUT THAT RANGE!) */
+ 	wii_board_4s_t raw; /* RAW */
+ 	wii_board_4s_t hs[3]; /* handshake data */
+ 	wii_board_4s_t cal; /* calibration data */
+ 	wii_board_4s_t prev; /* previous data */
+ 	wii_board_4s_t delta; /* difference between hs[2] and hs[0] */
+ 	vec2f_t pos; /* weight position (-1, 1)*/
+ 	float weight;
+ } wii_board_t;
+ 
  
  /**
   *	@struct expansion_t
***************
*** 457,467 ****
   */
  typedef struct expansion_t {
  	int type;						/**< type of expansion attached				*/
- 
  	union {
  		struct nunchuk_t nunchuk;
  		struct classic_ctrl_t classic;
  		struct guitar_hero_3_t gh3;
  	};
  } expansion_t;
  
--- 490,500 ----
   */
  typedef struct expansion_t {
  	int type;						/**< type of expansion attached				*/
  	union {
  		struct nunchuk_t nunchuk;
  		struct classic_ctrl_t classic;
  		struct guitar_hero_3_t gh3;
+ 		struct wii_board_t wb;
  	};
  } expansion_t;
  
***************
*** 489,495 ****
  	float exp_rjs_mag;
  	unsigned short exp_btns;
  	struct orient_t exp_orient;
! 	struct vec3b_t exp_accel;
  	float exp_r_shoulder;
  	float exp_l_shoulder;
  
--- 522,528 ----
  	float exp_rjs_mag;
  	unsigned short exp_btns;
  	struct orient_t exp_orient;
! 	struct vec3b_t exp_accel;
  	float exp_r_shoulder;
  	float exp_l_shoulder;
  
***************
*** 512,528 ****
  typedef enum WIIUSE_EVENT_TYPE {
  	WIIUSE_NONE = 0,
  	WIIUSE_EVENT,
! 	WIIUSE_STATUS,
  	WIIUSE_CONNECT,
! 	WIIUSE_DISCONNECT,
! 	WIIUSE_UNEXPECTED_DISCONNECT,
! 	WIIUSE_READ_DATA,
  	WIIUSE_NUNCHUK_INSERTED,
! 	WIIUSE_NUNCHUK_REMOVED,
! 	WIIUSE_CLASSIC_CTRL_INSERTED,
! 	WIIUSE_CLASSIC_CTRL_REMOVED,
! 	WIIUSE_GUITAR_HERO_3_CTRL_INSERTED,
! 	WIIUSE_GUITAR_HERO_3_CTRL_REMOVED
  } WIIUSE_EVENT_TYPE;
  
  /**
--- 545,563 ----
  typedef enum WIIUSE_EVENT_TYPE {
  	WIIUSE_NONE = 0,
  	WIIUSE_EVENT,
! 	WIIUSE_STATUS,
  	WIIUSE_CONNECT,
! 	WIIUSE_DISCONNECT,
! 	WIIUSE_UNEXPECTED_DISCONNECT,
! 	WIIUSE_READ_DATA,
  	WIIUSE_NUNCHUK_INSERTED,
! 	WIIUSE_NUNCHUK_REMOVED,
! 	WIIUSE_CLASSIC_CTRL_INSERTED,
! 	WIIUSE_CLASSIC_CTRL_REMOVED,
! 	WIIUSE_GUITAR_HERO_3_CTRL_INSERTED,
! 	WIIUSE_GUITAR_HERO_3_CTRL_REMOVED,
! 	WIIUSE_WII_BOARD_CTRL_INSERTED,
! 	WIIUSE_WII_BOARD_CTRL_REMOVED
  } WIIUSE_EVENT_TYPE;
  
  /**
***************
*** 550,557 ****
  	WCONST byte leds;						/**< currently lit leds						*/
  	WCONST float battery_level;				/**< battery level							*/
  
! 	WCONST int flags;						/**< options flag							*/
! 
  	WCONST byte handshake_state;			/**< the state of the connection handshake	*/
  
  	WCONST struct read_req_t* read_req;		/**< list of data read requests				*/
--- 585,592 ----
  	WCONST byte leds;						/**< currently lit leds						*/
  	WCONST float battery_level;				/**< battery level							*/
  
! 	WCONST int flags;						/**< options flag							*/
! 
  	WCONST byte handshake_state;			/**< the state of the connection handshake	*/
  
  	WCONST struct read_req_t* read_req;		/**< list of data read requests				*/
***************
*** 636,648 ****
  WIIUSE_EXPORT extern void wiiuse_set_ir(struct wiimote_t* wm, int status);
  WIIUSE_EXPORT extern void wiiuse_set_ir_vres(struct wiimote_t* wm, unsigned int x, unsigned int y);
  WIIUSE_EXPORT extern void wiiuse_set_ir_position(struct wiimote_t* wm, enum ir_position_t pos);
! WIIUSE_EXPORT extern void wiiuse_set_aspect_ratio(struct wiimote_t* wm, enum aspect_t aspect);
! WIIUSE_EXPORT extern void wiiuse_set_ir_sensitivity(struct wiimote_t* wm, int level);
! 
! /* nunchuk.c */
! WIIUSE_EXPORT extern void wiiuse_set_nunchuk_orient_threshold(struct wiimote_t* wm, float threshold);
! WIIUSE_EXPORT extern void wiiuse_set_nunchuk_accel_threshold(struct wiimote_t* wm, int threshold);
  
  
  #ifdef __cplusplus
  }
--- 671,685 ----
  WIIUSE_EXPORT extern void wiiuse_set_ir(struct wiimote_t* wm, int status);
  WIIUSE_EXPORT extern void wiiuse_set_ir_vres(struct wiimote_t* wm, unsigned int x, unsigned int y);
  WIIUSE_EXPORT extern void wiiuse_set_ir_position(struct wiimote_t* wm, enum ir_position_t pos);
! WIIUSE_EXPORT extern void wiiuse_set_aspect_ratio(struct wiimote_t* wm, enum aspect_t aspect);
! WIIUSE_EXPORT extern void wiiuse_set_ir_sensitivity(struct wiimote_t* wm, int level);
! 
! /* nunchuk.c */
! WIIUSE_EXPORT extern void wiiuse_set_nunchuk_orient_threshold(struct wiimote_t* wm, float threshold);
! WIIUSE_EXPORT extern void wiiuse_set_nunchuk_accel_threshold(struct wiimote_t* wm, int threshold);
  
+ /* Balance Board */
+ WIIUSE_EXPORT extern void wiiuse_set_wii_board_calib(struct wiimote_t *wm);
  
  #ifdef __cplusplus
  }
diff -crN wiiuse_v0.12/src/wiiuse_internal.h wiiuse_v0.12_bb_final/src/wiiuse_internal.h
*** wiiuse_v0.12/src/wiiuse_internal.h	2008-03-29 22:58:04.000000000 +0100
--- wiiuse_v0.12_bb_final/src/wiiuse_internal.h	2010-05-19 23:43:59.000000000 +0200
***************
*** 152,160 ****
  #define EXP_ID_CODE_NUNCHUK					0x9A1EFEFE
  #define EXP_ID_CODE_CLASSIC_CONTROLLER		0x9A1EFDFD
  #define EXP_ID_CODE_GUITAR					0x9A1EFDFB
  
- #define EXP_HANDSHAKE_LEN					224
- 
  /********************
   *
   *	End Wiimote internal codes
--- 152,161 ----
  #define EXP_ID_CODE_NUNCHUK					0x9A1EFEFE
  #define EXP_ID_CODE_CLASSIC_CONTROLLER		0x9A1EFDFD
  #define EXP_ID_CODE_GUITAR					0x9A1EFDFB
+ #define EXP_ID_CODE_WII_BOARD				0xA4200402
+ 
+ #define EXP_HANDSHAKE_LEN					224
  
  /********************
   *
   *	End Wiimote internal codes
***************
*** 205,214 ****
  #define WIIUSE_DEFAULT_SMOOTH_ALPHA		0.07f
  
  #define SMOOTH_ROLL						0x01
! #define SMOOTH_PITCH					0x02
! 
  #include "wiiuse.h"
! 
  #ifdef __cplusplus
  extern "C" {
  #endif
--- 206,215 ----
  #define WIIUSE_DEFAULT_SMOOTH_ALPHA		0.07f
  
  #define SMOOTH_ROLL						0x01
! #define SMOOTH_PITCH					0x02
! 
  #include "wiiuse.h"
! 
  #ifdef __cplusplus
  extern "C" {
  #endif
diff -crN wiiuse_v0.12/wiiuse_v0.12_bb_final.patch wiiuse_v0.12_bb_final/wiiuse_v0.12_bb_final.patch
*** wiiuse_v0.12/wiiuse_v0.12_bb_final.patch	2011-12-13 09:25:53.000000000 +0100
--- wiiuse_v0.12_bb_final/wiiuse_v0.12_bb_final.patch	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,2633 ****
- Only in wiiuse_v0.12_bb_final/example: example_bb.c
- diff -ur wiiuse_v0.12/src/Makefile wiiuse_v0.12_bb_final/src/Makefile
- --- wiiuse_v0.12/src/Makefile	2008-03-03 00:30:04.000000000 +0100
- +++ wiiuse_v0.12_bb_final/src/Makefile	2008-04-25 22:05:44.000000000 +0200
- @@ -56,6 +56,7 @@
-  	$(OBJ_DIR)/ir.o \
-  	$(OBJ_DIR)/nunchuk.o \
-  	$(OBJ_DIR)/guitar_hero_3.o \
- +	$(OBJ_DIR)/wiiboard.o \
-  	$(OBJ_DIR)/wiiuse.o
-  
-  ###############################
- diff -ur wiiuse_v0.12/src/classic.c wiiuse_v0.12_bb_final/src/classic.c
- --- wiiuse_v0.12/src/classic.c	2008-03-28 00:03:58.000000000 +0100
- +++ wiiuse_v0.12_bb_final/src/classic.c	2009-10-09 10:26:38.000000000 +0200
- @@ -1,74 +1,74 @@
- -/*
- - *	wiiuse
- - *
- - *	Written By:
- - *		Michael Laforest	< para >
- - *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- - *
- - *	Copyright 2006-2007
- - *
- - *	This file is part of wiiuse.
- - *
- - *	This program is free software; you can redistribute it and/or modify
- - *	it under the terms of the GNU General Public License as published by
- - *	the Free Software Foundation; either version 3 of the License, or
- - *	(at your option) any later version.
- - *
- - *	This program is distributed in the hope that it will be useful,
- - *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- - *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- - *	GNU General Public License for more details.
- - *
- - *	You should have received a copy of the GNU General Public License
- - *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- - *
- - *	$Header$
- - *
- - */
- -
- -/**
- - *	@file
- - *	@brief Classic controller expansion device.
- - */
- -
- -#include <stdio.h>
- -#include <stdlib.h>
- -#include <math.h>
- -
- -#ifdef WIN32
- -	#include <Winsock2.h>
- -#endif
- -
- -#include "definitions.h"
- -#include "wiiuse_internal.h"
- -#include "dynamics.h"
- -#include "events.h"
- -#include "classic.h"
- -
- -static void classic_ctrl_pressed_buttons(struct classic_ctrl_t* cc, short now);
- -
- -/**
- - *	@brief Handle the handshake data from the classic controller.
- - *
- - *	@param cc		A pointer to a classic_ctrl_t structure.
- - *	@param data		The data read in from the device.
- - *	@param len		The length of the data block, in bytes.
- - *
- - *	@return	Returns 1 if handshake was successful, 0 if not.
- - */
- -int classic_ctrl_handshake(struct wiimote_t* wm, struct classic_ctrl_t* cc, byte* data, unsigned short len) {
- +/*
- + *	wiiuse
- + *
- + *	Written By:
- + *		Michael Laforest	< para >
- + *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- + *
- + *	Copyright 2006-2007
- + *
- + *	This file is part of wiiuse.
- + *
- + *	This program is free software; you can redistribute it and/or modify
- + *	it under the terms of the GNU General Public License as published by
- + *	the Free Software Foundation; either version 3 of the License, or
- + *	(at your option) any later version.
- + *
- + *	This program is distributed in the hope that it will be useful,
- + *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- + *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- + *	GNU General Public License for more details.
- + *
- + *	You should have received a copy of the GNU General Public License
- + *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- + *
- + *	$Header$
- + *
- + */
- +
- +/**
- + *	@file
- + *	@brief Classic controller expansion device.
- + */
- +
- +#include <stdio.h>
- +#include <stdlib.h>
- +#include <math.h>
- +
- +#ifdef WIN32
- +	#include <Winsock2.h>
- +#endif
- +
- +#include "definitions.h"
- +#include "wiiuse_internal.h"
- +#include "dynamics.h"
- +#include "events.h"
- +#include "classic.h"
- +
- +static void classic_ctrl_pressed_buttons(struct classic_ctrl_t* cc, short now);
- +
- +/**
- + *	@brief Handle the handshake data from the classic controller.
- + *
- + *	@param cc		A pointer to a classic_ctrl_t structure.
- + *	@param data		The data read in from the device.
- + *	@param len		The length of the data block, in bytes.
- + *
- + *	@return	Returns 1 if handshake was successful, 0 if not.
- + */
- +int classic_ctrl_handshake(struct wiimote_t* wm, struct classic_ctrl_t* cc, byte* data, unsigned short len) {
-  	int i;
- -	int offset = 0;
- -
- -	cc->btns = 0;
- -	cc->btns_held = 0;
- -	cc->btns_released = 0;
- -	cc->r_shoulder = 0;
- -	cc->l_shoulder = 0;
- -
- -	/* decrypt data */
- -	for (i = 0; i < len; ++i)
- -		data[i] = (data[i] ^ 0x17) + 0x17;
- +	int offset = 0;
- +
- +	cc->btns = 0;
- +	cc->btns_held = 0;
- +	cc->btns_released = 0;
- +	cc->r_shoulder = 0;
- +	cc->l_shoulder = 0;
- +
- +	/* decrypt data */
- +	for (i = 0; i < len; ++i)
- +		data[i] = (data[i] ^ 0x17) + 0x17;
-  
-  	if (data[offset] == 0xFF) {
-  		/*
- @@ -93,98 +93,98 @@
-  			offset += 16;
-  	}
-  
- -
- -	/* joystick stuff */
- -	cc->ljs.max.x = data[0 + offset] / 4;
- -	cc->ljs.min.x = data[1 + offset] / 4;
- -	cc->ljs.center.x = data[2 + offset] / 4;
- -	cc->ljs.max.y = data[3 + offset] / 4;
- -	cc->ljs.min.y = data[4 + offset] / 4;
- -	cc->ljs.center.y = data[5 + offset] / 4;
- -
- -	cc->rjs.max.x = data[6 + offset] / 8;
- -	cc->rjs.min.x = data[7 + offset] / 8;
- -	cc->rjs.center.x = data[8 + offset] / 8;
- -	cc->rjs.max.y = data[9 + offset] / 8;
- -	cc->rjs.min.y = data[10 + offset] / 8;
- -	cc->rjs.center.y = data[11 + offset] / 8;
- -
- -	/* handshake done */
- -	wm->exp.type = EXP_CLASSIC;
- -
- -	#ifdef WIN32
- -	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
- -	#endif
- -
- -	return 1;
- -}
- -
- -
- -/**
- - *	@brief The classic controller disconnected.
- - *
- - *	@param cc		A pointer to a classic_ctrl_t structure.
- - */
- -void classic_ctrl_disconnected(struct classic_ctrl_t* cc) {
- -	memset(cc, 0, sizeof(struct classic_ctrl_t));
- -}
- -
- -
- -
- -/**
- - *	@brief Handle classic controller event.
- - *
- - *	@param cc		A pointer to a classic_ctrl_t structure.
- - *	@param msg		The message specified in the event packet.
- - */
- -void classic_ctrl_event(struct classic_ctrl_t* cc, byte* msg) {
- -	int i, lx, ly, rx, ry;
- -	byte l, r;
- -
- -	/* decrypt data */
- -	for (i = 0; i < 6; ++i)
- -		msg[i] = (msg[i] ^ 0x17) + 0x17;
- -
- -	classic_ctrl_pressed_buttons(cc, BIG_ENDIAN_SHORT(*(short*)(msg + 4)));
- -
- -	/* left/right buttons */
- -	l = (((msg[2] & 0x60) >> 2) | ((msg[3] & 0xE0) >> 5));
- -	r = (msg[3] & 0x1F);
- -
- -	/*
- -	 *	TODO - LR range hardcoded from 0x00 to 0x1F.
- -	 *	This is probably in the calibration somewhere.
- -	 */
- -	cc->r_shoulder = ((float)r / 0x1F);
- -	cc->l_shoulder = ((float)l / 0x1F);
- -
- -	/* calculate joystick orientation */
- -	lx = (msg[0] & 0x3F);
- -	ly = (msg[1] & 0x3F);
- -	rx = ((msg[0] & 0xC0) >> 3) | ((msg[1] & 0xC0) >> 5) | ((msg[2] & 0x80) >> 7);
- -	ry = (msg[2] & 0x1F);
- -
- -	calc_joystick_state(&cc->ljs, lx, ly);
- -	calc_joystick_state(&cc->rjs, rx, ry);
- -}
- -
- -
- -/**
- - *	@brief Find what buttons are pressed.
- - *
- - *	@param cc		A pointer to a classic_ctrl_t structure.
- - *	@param msg		The message byte specified in the event packet.
- - */
- -static void classic_ctrl_pressed_buttons(struct classic_ctrl_t* cc, short now) {
- -	/* message is inverted (0 is active, 1 is inactive) */
- -	now = ~now & CLASSIC_CTRL_BUTTON_ALL;
- -
- -	/* pressed now & were pressed, then held */
- -	cc->btns_held = (now & cc->btns);
- -
- -	/* were pressed or were held & not pressed now, then released */
- -	cc->btns_released = ((cc->btns | cc->btns_held) & ~now);
- -
- -	/* buttons pressed now */
- -	cc->btns = now;
- -}
- +
- +	/* joystick stuff */
- +	cc->ljs.max.x = data[0 + offset] / 4;
- +	cc->ljs.min.x = data[1 + offset] / 4;
- +	cc->ljs.center.x = data[2 + offset] / 4;
- +	cc->ljs.max.y = data[3 + offset] / 4;
- +	cc->ljs.min.y = data[4 + offset] / 4;
- +	cc->ljs.center.y = data[5 + offset] / 4;
- +
- +	cc->rjs.max.x = data[6 + offset] / 8;
- +	cc->rjs.min.x = data[7 + offset] / 8;
- +	cc->rjs.center.x = data[8 + offset] / 8;
- +	cc->rjs.max.y = data[9 + offset] / 8;
- +	cc->rjs.min.y = data[10 + offset] / 8;
- +	cc->rjs.center.y = data[11 + offset] / 8;
- +
- +	/* handshake done */
- +	wm->exp.type = EXP_CLASSIC;
- +
- +	#ifdef WIN32
- +	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
- +	#endif
- +
- +	return 1;
- +}
- +
- +
- +/**
- + *	@brief The classic controller disconnected.
- + *
- + *	@param cc		A pointer to a classic_ctrl_t structure.
- + */
- +void classic_ctrl_disconnected(struct classic_ctrl_t* cc) {
- +	memset(cc, 0, sizeof(struct classic_ctrl_t));
- +}
- +
- +
- +
- +/**
- + *	@brief Handle classic controller event.
- + *
- + *	@param cc		A pointer to a classic_ctrl_t structure.
- + *	@param msg		The message specified in the event packet.
- + */
- +void classic_ctrl_event(struct classic_ctrl_t* cc, byte* msg) {
- +	int i, lx, ly, rx, ry;
- +	byte l, r;
- +
- +	/* decrypt data */
- +	for (i = 0; i < 6; ++i)
- +		msg[i] = (msg[i] ^ 0x17) + 0x17;
- +
- +	classic_ctrl_pressed_buttons(cc, BIG_ENDIAN_SHORT(*(short*)(msg + 4)));
- +
- +	/* left/right buttons */
- +	l = (((msg[2] & 0x60) >> 2) | ((msg[3] & 0xE0) >> 5));
- +	r = (msg[3] & 0x1F);
- +
- +	/*
- +	 *	TODO - LR range hardcoded from 0x00 to 0x1F.
- +	 *	This is probably in the calibration somewhere.
- +	 */
- +	cc->r_shoulder = ((float)r / 0x1F);
- +	cc->l_shoulder = ((float)l / 0x1F);
- +
- +	/* calculate joystick orientation */
- +	lx = (msg[0] & 0x3F);
- +	ly = (msg[1] & 0x3F);
- +	rx = ((msg[0] & 0xC0) >> 3) | ((msg[1] & 0xC0) >> 5) | ((msg[2] & 0x80) >> 7);
- +	ry = (msg[2] & 0x1F);
- +
- +	calc_joystick_state(&cc->ljs, lx, ly);
- +	calc_joystick_state(&cc->rjs, rx, ry);
- +}
- +
- +
- +/**
- + *	@brief Find what buttons are pressed.
- + *
- + *	@param cc		A pointer to a classic_ctrl_t structure.
- + *	@param msg		The message byte specified in the event packet.
- + */
- +static void classic_ctrl_pressed_buttons(struct classic_ctrl_t* cc, short now) {
- +	/* message is inverted (0 is active, 1 is inactive) */
- +	now = ~now & CLASSIC_CTRL_BUTTON_ALL;
- +
- +	/* pressed now & were pressed, then held */
- +	cc->btns_held = (now & cc->btns);
- +
- +	/* were pressed or were held & not pressed now, then released */
- +	cc->btns_released = ((cc->btns | cc->btns_held) & ~now);
- +
- +	/* buttons pressed now */
- +	cc->btns = now;
- +}
- diff -ur wiiuse_v0.12/src/definitions.h wiiuse_v0.12_bb_final/src/definitions.h
- --- wiiuse_v0.12/src/definitions.h	2008-04-02 03:39:35.000000000 +0200
- +++ wiiuse_v0.12_bb_final/src/definitions.h	2009-10-14 10:05:14.000000000 +0200
- @@ -1,55 +1,55 @@
- -/*
- - *	wiiuse
- - *
- - *	Written By:
- - *		Michael Laforest	< para >
- - *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- - *
- - *	Copyright 2006-2007
- - *
- - *	This file is part of wiiuse.
- - *
- - *	This program is free software; you can redistribute it and/or modify
- - *	it under the terms of the GNU General Public License as published by
- - *	the Free Software Foundation; either version 3 of the License, or
- - *	(at your option) any later version.
- - *
- - *	This program is distributed in the hope that it will be useful,
- - *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- - *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- - *	GNU General Public License for more details.
- - *
- - *	You should have received a copy of the GNU General Public License
- - *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- - *
- - *	$Header$
- - *
- - */
- -
- -/**
- - *	@file
- - *	@brief General definitions.
- - */
- -
- -#ifndef DEFINITIONS_H_INCLUDED
- -#define DEFINITIONS_H_INCLUDED
- -
- -/* this is wiiuse - used to distinguish from third party programs using wiiuse.h */
- -#include "os.h"
- -
- -#define WIIMOTE_PI			3.14159265f
- -
- -//#define WITH_WIIUSE_DEBUG
- -
- -/* Error output macros */
- -#define WIIUSE_ERROR(fmt, ...)		fprintf(stderr, "[ERROR] " fmt "\n", ##__VA_ARGS__)
- -
- -/* Warning output macros */
- -#define WIIUSE_WARNING(fmt, ...)	fprintf(stderr, "[WARNING] " fmt "\n",	##__VA_ARGS__)
- -
- -/* Information output macros */
- -#define WIIUSE_INFO(fmt, ...)		fprintf(stderr, "[INFO] " fmt "\n", ##__VA_ARGS__)
- -
- +/*
- + *	wiiuse
- + *
- + *	Written By:
- + *		Michael Laforest	< para >
- + *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- + *
- + *	Copyright 2006-2007
- + *
- + *	This file is part of wiiuse.
- + *
- + *	This program is free software; you can redistribute it and/or modify
- + *	it under the terms of the GNU General Public License as published by
- + *	the Free Software Foundation; either version 3 of the License, or
- + *	(at your option) any later version.
- + *
- + *	This program is distributed in the hope that it will be useful,
- + *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- + *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- + *	GNU General Public License for more details.
- + *
- + *	You should have received a copy of the GNU General Public License
- + *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- + *
- + *	$Header$
- + *
- + */
- +
- +/**
- + *	@file
- + *	@brief General definitions.
- + */
- +
- +#ifndef DEFINITIONS_H_INCLUDED
- +#define DEFINITIONS_H_INCLUDED
- +
- +/* this is wiiuse - used to distinguish from third party programs using wiiuse.h */
- +#include "os.h"
- +
- +#define WIIMOTE_PI			3.14159265f
- +
- +//#define WITH_WIIUSE_DEBUG
- +
- +/* Error output macros */
- +#define WIIUSE_ERROR(fmt, ...)		fprintf(stderr, "[ERROR] " fmt "\n", ##__VA_ARGS__)
- +
- +/* Warning output macros */
- +#define WIIUSE_WARNING(fmt, ...)	fprintf(stderr, "[WARNING] " fmt "\n",	##__VA_ARGS__)
- +
- +/* Information output macros */
- +#define WIIUSE_INFO(fmt, ...)		fprintf(stderr, "[INFO] " fmt "\n", ##__VA_ARGS__)
- +
-  #ifdef WITH_WIIUSE_DEBUG
-  	#ifdef WIN32
-  		#define WIIUSE_DEBUG(fmt, ...)		do {																				\
- @@ -58,22 +58,25 @@
-  												for (; i && (file[i] != '\\'); --i);											\
-  												fprintf(stderr, "[DEBUG] %s:%i: " fmt "\n", file+i+1, __LINE__, ##__VA_ARGS__);	\
-  											} while (0)
- -	#else
- +	#else
-  		#define WIIUSE_DEBUG(fmt, ...)	fprintf(stderr, "[DEBUG] " __FILE__ ":%i: " fmt "\n", __LINE__, ##__VA_ARGS__)
- -	#endif
- -#else
- -	#define WIIUSE_DEBUG(fmt, ...)
- -#endif
- -
- -/* Convert between radians and degrees */
- -#define RAD_TO_DEGREE(r)	((r * 180.0f) / WIIMOTE_PI)
- -#define DEGREE_TO_RAD(d)	(d * (WIIMOTE_PI / 180.0f))
- -
- -/* Convert to big endian */
- -#define BIG_ENDIAN_LONG(i)				(htonl(i))
- -#define BIG_ENDIAN_SHORT(i)				(htons(i))
- -
- -#define absf(x)						((x >= 0) ? (x) : (x * -1.0f))
- -#define diff_f(x, y)				((x >= y) ? (absf(x - y)) : (absf(y - x)))
- -
- -#endif // DEFINITIONS_H_INCLUDED
- +	#endif
- +#else
- +	#define WIIUSE_DEBUG(fmt, ...)
- +#endif
- +
- +/* Convert between radians and degrees */
- +#define RAD_TO_DEGREE(r)	((r * 180.0f) / WIIMOTE_PI)
- +#define DEGREE_TO_RAD(d)	(d * (WIIMOTE_PI / 180.0f))
- +
- +/* Convert to big endian */
- +#define BIG_ENDIAN_LONG(i)				(htonl(i))
- +#define BIG_ENDIAN_SHORT(i)				(htons(i))
- +
- +#define absf(x)						((x >= 0) ? (x) : (x * -1.0f))
- +#define diff_f(x, y)				((x >= y) ? (absf(x - y)) : (absf(y - x)))
- +
- +/* Balance Board max value */
- +#define MAX_WB_VAL 136
- +
- +#endif // DEFINITIONS_H_INCLUDED
- diff -ur wiiuse_v0.12/src/events.c wiiuse_v0.12_bb_final/src/events.c
- --- wiiuse_v0.12/src/events.c	2008-04-02 01:13:47.000000000 +0200
- +++ wiiuse_v0.12_bb_final/src/events.c	2009-10-12 11:10:24.000000000 +0200
- @@ -39,9 +39,9 @@
-  #ifndef WIN32
-  	#include <sys/time.h>
-  	#include <unistd.h>
- -	#include <errno.h>
- +	#include <errno.h>
-  #else
- -	#include <winsock2.h>
- +	#include <winsock2.h>
-  #endif
-  
-  #include <sys/types.h>
- @@ -56,10 +56,11 @@
-  #include "nunchuk.h"
-  #include "classic.h"
-  #include "guitar_hero_3.h"
- +#include "wiiboard.h"
-  #include "events.h"
-  
-  static void idle_cycle(struct wiimote_t* wm);
- -static void clear_dirty_reads(struct wiimote_t* wm);
- +static void clear_dirty_reads(struct wiimote_t* wm);
-  static void propagate_event(struct wiimote_t* wm, byte event, byte* msg);
-  static void event_data_read(struct wiimote_t* wm, byte* msg);
-  static void event_status(struct wiimote_t* wm, byte* msg);
- @@ -132,24 +133,24 @@
-  
-  			if (FD_ISSET(wm[i]->in_sock, &fds)) {
-  				/* clear out the event buffer */
- -				memset(wm[i]->event_buf, 0, sizeof(wm[i]->event_buf));
- -
- -				/* clear out any old read requests */
- +				memset(wm[i]->event_buf, 0, sizeof(wm[i]->event_buf));
- +
- +				/* clear out any old read requests */
-  				clear_dirty_reads(wm[i]);
-  
-  				/* read the pending message into the buffer */
-  				r = read(wm[i]->in_sock, wm[i]->event_buf, sizeof(wm[i]->event_buf));
-  				if (r == -1) {
-  					/* error reading data */
- -					WIIUSE_ERROR("Receiving wiimote data (id %i).", wm[i]->unid);
- -					perror("Error Details");
- -
- -					if (errno == ENOTCONN) {
- -						/* this can happen if the bluetooth dongle is disconnected */
- -						WIIUSE_ERROR("Bluetooth appears to be disconnected.  Wiimote unid %i will be disconnected.", wm[i]->unid);
- -						wiiuse_disconnect(wm[i]);
- -						wm[i]->event = WIIUSE_UNEXPECTED_DISCONNECT;
- -					}
- +					WIIUSE_ERROR("Receiving wiimote data (id %i).", wm[i]->unid);
- +					perror("Error Details");
- +
- +					if (errno == ENOTCONN) {
- +						/* this can happen if the bluetooth dongle is disconnected */
- +						WIIUSE_ERROR("Bluetooth appears to be disconnected.  Wiimote unid %i will be disconnected.", wm[i]->unid);
- +						wiiuse_disconnect(wm[i]);
- +						wm[i]->event = WIIUSE_UNEXPECTED_DISCONNECT;
- +					}
-  
-  					continue;
-  				}
- @@ -216,27 +217,27 @@
-  		apply_smoothing(&wm->accel_calib, &wm->orient, SMOOTH_ROLL);
-  		apply_smoothing(&wm->accel_calib, &wm->orient, SMOOTH_PITCH);
-  	}
- -
- -	/* clear out any old read requests */
- -	clear_dirty_reads(wm);
- -}
- -
- -
- -/**
- - *	@brief Clear out all old 'dirty' read requests.
- - *
- - *	@param wm		Pointer to a wiimote_t structure.
- - */
- -static void clear_dirty_reads(struct wiimote_t* wm) {
- -	struct read_req_t* req = wm->read_req;
- -
- -	while (req && req->dirty) {
- -		WIIUSE_DEBUG("Cleared old read request for address: %x", req->addr);
- -
- -		wm->read_req = req->next;
- -		free(req);
- -		req = wm->read_req;
- -	}
- +
- +	/* clear out any old read requests */
- +	clear_dirty_reads(wm);
- +}
- +
- +
- +/**
- + *	@brief Clear out all old 'dirty' read requests.
- + *
- + *	@param wm		Pointer to a wiimote_t structure.
- + */
- +static void clear_dirty_reads(struct wiimote_t* wm) {
- +	struct read_req_t* req = wm->read_req;
- +
- +	while (req && req->dirty) {
- +		WIIUSE_DEBUG("Cleared old read request for address: %x", req->addr);
- +
- +		wm->read_req = req->next;
- +		free(req);
- +		req = wm->read_req;
- +	}
-  }
-  
-  
- @@ -424,10 +425,10 @@
-  	struct read_req_t* req = wm->read_req;
-  
-  	wiiuse_pressed_buttons(wm, msg);
- -
- -	/* find the next non-dirty request */
- -	while (req && req->dirty)
- -		req = req->next;
- +
- +	/* find the next non-dirty request */
- +	while (req && req->dirty)
- +		req = req->next;
-  
-  	/* if we don't have a request out then we didn't ask for this packet */
-  	if (!req) {
- @@ -488,24 +489,24 @@
-  	#endif
-  
-  	/* if all data has been received, execute the read event callback or generate event */
- -	if (!req->wait) {
- -		if (req->cb) {
- +	if (!req->wait) {
- +		if (req->cb) {
-  			/* this was a callback, so invoke it now */
-  			req->cb(wm, req->buf, req->size);
-  
-  			/* delete this request */
-  			wm->read_req = req->next;
- -			free(req);
- -		} else {
- -			/*
- -			 *	This should generate an event.
- -			 *	We need to leave the event in the array so the client
- -			 *	can access it still.  We'll flag is as being 'dirty'
- -			 *	and give the client one cycle to use it.  Next event
- -			 *	we will remove it from the list.
- -			 */
- -			wm->event = WIIUSE_READ_DATA;
- -			req->dirty = 1;
- +			free(req);
- +		} else {
- +			/*
- +			 *	This should generate an event.
- +			 *	We need to leave the event in the array so the client
- +			 *	can access it still.  We'll flag is as being 'dirty'
- +			 *	and give the client one cycle to use it.  Next event
- +			 *	we will remove it from the list.
- +			 */
- +			wm->event = WIIUSE_READ_DATA;
- +			req->dirty = 1;
-  		}
-  
-  		/* if another request exists send it to the wiimote */
- @@ -611,6 +612,9 @@
-  		case EXP_GUITAR_HERO_3:
-  			guitar_hero_3_event(&wm->exp.gh3, msg);
-  			break;
- +		case EXP_WII_BOARD:
- +			wii_board_event(&wm->exp.wb, msg);
- +			break;
-  		default:
-  			break;
-  	}
- @@ -669,9 +673,9 @@
-  			break;
-  		}
-  		case EXP_ID_CODE_CLASSIC_CONTROLLER:
- -		{
- +		{
-  			if (classic_ctrl_handshake(wm, &wm->exp.classic, data, len))
- -				wm->event = WIIUSE_CLASSIC_CTRL_INSERTED;
- +				wm->event = WIIUSE_CLASSIC_CTRL_INSERTED;
-  			break;
-  		}
-  		case EXP_ID_CODE_GUITAR:
- @@ -680,6 +684,12 @@
-  				wm->event = WIIUSE_GUITAR_HERO_3_CTRL_INSERTED;
-  			break;
-  		}
- +		case EXP_ID_CODE_WII_BOARD:
- +		{
- +			if (wii_board_handshake(wm, &wm->exp.wb, data, len))
- +				wm->event = WIIUSE_WII_BOARD_CTRL_INSERTED;
- +			break;
- +		}
-  		default:
-  		{
-  			WIIUSE_WARNING("Unknown expansion type. Code: 0x%x", id);
- @@ -720,6 +730,10 @@
-  			guitar_hero_3_disconnected(&wm->exp.gh3);
-  			wm->event = WIIUSE_GUITAR_HERO_3_CTRL_REMOVED;
-  			break;
- +		case EXP_WII_BOARD:
- +			guitar_hero_3_disconnected(&wm->exp.gh3);
- +			wm->event = WIIUSE_GUITAR_HERO_3_CTRL_REMOVED;
- +			break;
-  		default:
-  			break;
-  	}
- @@ -866,6 +880,14 @@
-  			STATE_CHANGED(wm->lstate.exp_btns, wm->exp.gh3.btns);
-  			break;
-  		}
- +		case EXP_WII_BOARD:
- +		{
- +			STATE_CHANGED(wm->exp.wb.prev.tr,wm->exp.wb.raw.tr);
- +			STATE_CHANGED(wm->exp.wb.prev.tl,wm->exp.wb.raw.tl);
- +			STATE_CHANGED(wm->exp.wb.prev.br,wm->exp.wb.raw.br);
- +			STATE_CHANGED(wm->exp.wb.prev.bl,wm->exp.wb.raw.bl);
- +			break;
- +		}
-  		case EXP_NONE:
-  		{
-  			break;
- diff -ur wiiuse_v0.12/src/events.h wiiuse_v0.12_bb_final/src/events.h
- --- wiiuse_v0.12/src/events.h	2008-02-12 02:22:37.000000000 +0100
- +++ wiiuse_v0.12_bb_final/src/events.h	2009-10-09 10:26:38.000000000 +0200
- @@ -1,54 +1,54 @@
- -/*
- - *	wiiuse
- - *
- - *	Written By:
- - *		Michael Laforest	< para >
- - *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- - *
- - *	Copyright 2006-2007
- - *
- - *	This file is part of wiiuse.
- - *
- - *	This program is free software; you can redistribute it and/or modify
- - *	it under the terms of the GNU General Public License as published by
- - *	the Free Software Foundation; either version 3 of the License, or
- - *	(at your option) any later version.
- - *
- - *	This program is distributed in the hope that it will be useful,
- - *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- - *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- - *	GNU General Public License for more details.
- - *
- - *	You should have received a copy of the GNU General Public License
- - *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- - *
- - *	$Header$
- - *
- - */
- -
- -/**
- - *	@file
- - *	@brief Handles wiimote events.
- - *
- - *	The file includes functions that handle the events
- - *	that are sent from the wiimote to us.
- - */
- -
- -#ifndef EVENTS_H_INCLUDED
- -#define EVENTS_H_INCLUDED
- -
- -#ifdef __cplusplus
- -extern "C" {
- -#endif
- -
- -void wiiuse_pressed_buttons(struct wiimote_t* wm, byte* msg);
- -
- -void handshake_expansion(struct wiimote_t* wm, byte* data, unsigned short len);
- +/*
- + *	wiiuse
- + *
- + *	Written By:
- + *		Michael Laforest	< para >
- + *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- + *
- + *	Copyright 2006-2007
- + *
- + *	This file is part of wiiuse.
- + *
- + *	This program is free software; you can redistribute it and/or modify
- + *	it under the terms of the GNU General Public License as published by
- + *	the Free Software Foundation; either version 3 of the License, or
- + *	(at your option) any later version.
- + *
- + *	This program is distributed in the hope that it will be useful,
- + *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- + *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- + *	GNU General Public License for more details.
- + *
- + *	You should have received a copy of the GNU General Public License
- + *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- + *
- + *	$Header$
- + *
- + */
- +
- +/**
- + *	@file
- + *	@brief Handles wiimote events.
- + *
- + *	The file includes functions that handle the events
- + *	that are sent from the wiimote to us.
- + */
- +
- +#ifndef EVENTS_H_INCLUDED
- +#define EVENTS_H_INCLUDED
- +
- +#ifdef __cplusplus
- +extern "C" {
- +#endif
- +
- +void wiiuse_pressed_buttons(struct wiimote_t* wm, byte* msg);
- +
- +void handshake_expansion(struct wiimote_t* wm, byte* data, unsigned short len);
-  void disable_expansion(struct wiimote_t* wm);
- -
- -#ifdef __cplusplus
- -}
- -#endif
- -
- -
- -#endif // EVENTS_H_INCLUDED
- +
- +#ifdef __cplusplus
- +}
- +#endif
- +
- +
- +#endif // EVENTS_H_INCLUDED
- diff -ur wiiuse_v0.12/src/guitar_hero_3.c wiiuse_v0.12_bb_final/src/guitar_hero_3.c
- --- wiiuse_v0.12/src/guitar_hero_3.c	2008-03-28 00:04:43.000000000 +0100
- +++ wiiuse_v0.12_bb_final/src/guitar_hero_3.c	2009-10-09 10:26:38.000000000 +0200
- @@ -1,79 +1,79 @@
- -/*
- - *	wiiuse
- - *
- - *	Written By:
- - *		Michael Laforest	< para >
- - *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- - *
- - *	Copyright 2006-2007
- - *
- - *	This file is part of wiiuse.
- - *
- - *	This program is free software; you can redistribute it and/or modify
- - *	it under the terms of the GNU General Public License as published by
- - *	the Free Software Foundation; either version 3 of the License, or
- - *	(at your option) any later version.
- - *
- - *	This program is distributed in the hope that it will be useful,
- - *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- - *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- - *	GNU General Public License for more details.
- - *
- - *	You should have received a copy of the GNU General Public License
- - *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- - *
- - *	$Header$
- - *
- - */
- -
- -/**
- - *	@file
- - *	@brief Guitar Hero 3 expansion device.
- - */
- -
- -#include <stdio.h>
- -#include <stdlib.h>
- -#include <math.h>
- -
- -#ifdef WIN32
- -	#include <Winsock2.h>
- -#endif
- -
- -#include "definitions.h"
- -#include "wiiuse_internal.h"
- -#include "dynamics.h"
- -#include "events.h"
- -#include "guitar_hero_3.h"
- -
- -static void guitar_hero_3_pressed_buttons(struct guitar_hero_3_t* gh3, short now);
- -
- -/**
- - *	@brief Handle the handshake data from the guitar.
- - *
- - *	@param cc		A pointer to a classic_ctrl_t structure.
- - *	@param data		The data read in from the device.
- - *	@param len		The length of the data block, in bytes.
- - *
- - *	@return	Returns 1 if handshake was successful, 0 if not.
- - */
- -int guitar_hero_3_handshake(struct wiimote_t* wm, struct guitar_hero_3_t* gh3, byte* data, unsigned short len) {
- +/*
- + *	wiiuse
- + *
- + *	Written By:
- + *		Michael Laforest	< para >
- + *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- + *
- + *	Copyright 2006-2007
- + *
- + *	This file is part of wiiuse.
- + *
- + *	This program is free software; you can redistribute it and/or modify
- + *	it under the terms of the GNU General Public License as published by
- + *	the Free Software Foundation; either version 3 of the License, or
- + *	(at your option) any later version.
- + *
- + *	This program is distributed in the hope that it will be useful,
- + *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- + *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- + *	GNU General Public License for more details.
- + *
- + *	You should have received a copy of the GNU General Public License
- + *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- + *
- + *	$Header$
- + *
- + */
- +
- +/**
- + *	@file
- + *	@brief Guitar Hero 3 expansion device.
- + */
- +
- +#include <stdio.h>
- +#include <stdlib.h>
- +#include <math.h>
- +
- +#ifdef WIN32
- +	#include <Winsock2.h>
- +#endif
- +
- +#include "definitions.h"
- +#include "wiiuse_internal.h"
- +#include "dynamics.h"
- +#include "events.h"
- +#include "guitar_hero_3.h"
- +
- +static void guitar_hero_3_pressed_buttons(struct guitar_hero_3_t* gh3, short now);
- +
- +/**
- + *	@brief Handle the handshake data from the guitar.
- + *
- + *	@param cc		A pointer to a classic_ctrl_t structure.
- + *	@param data		The data read in from the device.
- + *	@param len		The length of the data block, in bytes.
- + *
- + *	@return	Returns 1 if handshake was successful, 0 if not.
- + */
- +int guitar_hero_3_handshake(struct wiimote_t* wm, struct guitar_hero_3_t* gh3, byte* data, unsigned short len) {
-  	int i;
- -	int offset = 0;
- -
- -	/*
- -	 *	The good fellows that made the Guitar Hero 3 controller
- -	 *	failed to factory calibrate the devices.  There is no
- -	 *	calibration data on the device.
- -	 */
- -
- -	gh3->btns = 0;
- -	gh3->btns_held = 0;
- -	gh3->btns_released = 0;
- -	gh3->whammy_bar = 0.0f;
- -
- -	/* decrypt data */
- -	for (i = 0; i < len; ++i)
- -		data[i] = (data[i] ^ 0x17) + 0x17;
- +	int offset = 0;
- +
- +	/*
- +	 *	The good fellows that made the Guitar Hero 3 controller
- +	 *	failed to factory calibrate the devices.  There is no
- +	 *	calibration data on the device.
- +	 */
- +
- +	gh3->btns = 0;
- +	gh3->btns_held = 0;
- +	gh3->btns_released = 0;
- +	gh3->whammy_bar = 0.0f;
- +
- +	/* decrypt data */
- +	for (i = 0; i < len; ++i)
- +		data[i] = (data[i] ^ 0x17) + 0x17;
-  
-  	if (data[offset] == 0xFF) {
-  		/*
- @@ -97,76 +97,76 @@
-  		} else
-  			offset += 16;
-  	}
- -
- -	/* joystick stuff */
- -	gh3->js.max.x = GUITAR_HERO_3_JS_MAX_X;
- -	gh3->js.min.x = GUITAR_HERO_3_JS_MIN_X;
- -	gh3->js.center.x = GUITAR_HERO_3_JS_CENTER_X;
- -	gh3->js.max.y = GUITAR_HERO_3_JS_MAX_Y;
- -	gh3->js.min.y = GUITAR_HERO_3_JS_MIN_Y;
- -	gh3->js.center.y = GUITAR_HERO_3_JS_CENTER_Y;
- -
- -	/* handshake done */
- -	wm->exp.type = EXP_GUITAR_HERO_3;
- -
- -	#ifdef WIN32
- -	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
- -	#endif
- -
- -	return 1;
- -}
- -
- -
- -/**
- - *	@brief The guitar disconnected.
- - *
- - *	@param cc		A pointer to a classic_ctrl_t structure.
- - */
- -void guitar_hero_3_disconnected(struct guitar_hero_3_t* gh3) {
- -	memset(gh3, 0, sizeof(struct guitar_hero_3_t));
- -}
- -
- -
- -
- -/**
- - *	@brief Handle guitar event.
- - *
- - *	@param cc		A pointer to a classic_ctrl_t structure.
- - *	@param msg		The message specified in the event packet.
- - */
- -void guitar_hero_3_event(struct guitar_hero_3_t* gh3, byte* msg) {
- -	int i;
- -
- -	/* decrypt data */
- -	for (i = 0; i < 6; ++i)
- -		msg[i] = (msg[i] ^ 0x17) + 0x17;
- -
- -	guitar_hero_3_pressed_buttons(gh3, BIG_ENDIAN_SHORT(*(short*)(msg + 4)));
- -
- -	/* whammy bar */
- -	gh3->whammy_bar = (msg[3] - GUITAR_HERO_3_WHAMMY_BAR_MIN) / (float)(GUITAR_HERO_3_WHAMMY_BAR_MAX - GUITAR_HERO_3_WHAMMY_BAR_MIN);
- -
- -	/* joy stick */
- -	calc_joystick_state(&gh3->js, msg[0], msg[1]);
- -}
- -
- -
- -/**
- - *	@brief Find what buttons are pressed.
- - *
- - *	@param cc		A pointer to a classic_ctrl_t structure.
- - *	@param msg		The message byte specified in the event packet.
- - */
- -static void guitar_hero_3_pressed_buttons(struct guitar_hero_3_t* gh3, short now) {
- -	/* message is inverted (0 is active, 1 is inactive) */
- -	now = ~now & GUITAR_HERO_3_BUTTON_ALL;
- -
- -	/* pressed now & were pressed, then held */
- -	gh3->btns_held = (now & gh3->btns);
- -
- -	/* were pressed or were held & not pressed now, then released */
- -	gh3->btns_released = ((gh3->btns | gh3->btns_held) & ~now);
- -
- -	/* buttons pressed now */
- -	gh3->btns = now;
- -}
- +
- +	/* joystick stuff */
- +	gh3->js.max.x = GUITAR_HERO_3_JS_MAX_X;
- +	gh3->js.min.x = GUITAR_HERO_3_JS_MIN_X;
- +	gh3->js.center.x = GUITAR_HERO_3_JS_CENTER_X;
- +	gh3->js.max.y = GUITAR_HERO_3_JS_MAX_Y;
- +	gh3->js.min.y = GUITAR_HERO_3_JS_MIN_Y;
- +	gh3->js.center.y = GUITAR_HERO_3_JS_CENTER_Y;
- +
- +	/* handshake done */
- +	wm->exp.type = EXP_GUITAR_HERO_3;
- +
- +	#ifdef WIN32
- +	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
- +	#endif
- +
- +	return 1;
- +}
- +
- +
- +/**
- + *	@brief The guitar disconnected.
- + *
- + *	@param cc		A pointer to a classic_ctrl_t structure.
- + */
- +void guitar_hero_3_disconnected(struct guitar_hero_3_t* gh3) {
- +	memset(gh3, 0, sizeof(struct guitar_hero_3_t));
- +}
- +
- +
- +
- +/**
- + *	@brief Handle guitar event.
- + *
- + *	@param cc		A pointer to a classic_ctrl_t structure.
- + *	@param msg		The message specified in the event packet.
- + */
- +void guitar_hero_3_event(struct guitar_hero_3_t* gh3, byte* msg) {
- +	int i;
- +
- +	/* decrypt data */
- +	for (i = 0; i < 6; ++i)
- +		msg[i] = (msg[i] ^ 0x17) + 0x17;
- +
- +	guitar_hero_3_pressed_buttons(gh3, BIG_ENDIAN_SHORT(*(short*)(msg + 4)));
- +
- +	/* whammy bar */
- +	gh3->whammy_bar = (msg[3] - GUITAR_HERO_3_WHAMMY_BAR_MIN) / (float)(GUITAR_HERO_3_WHAMMY_BAR_MAX - GUITAR_HERO_3_WHAMMY_BAR_MIN);
- +
- +	/* joy stick */
- +	calc_joystick_state(&gh3->js, msg[0], msg[1]);
- +}
- +
- +
- +/**
- + *	@brief Find what buttons are pressed.
- + *
- + *	@param cc		A pointer to a classic_ctrl_t structure.
- + *	@param msg		The message byte specified in the event packet.
- + */
- +static void guitar_hero_3_pressed_buttons(struct guitar_hero_3_t* gh3, short now) {
- +	/* message is inverted (0 is active, 1 is inactive) */
- +	now = ~now & GUITAR_HERO_3_BUTTON_ALL;
- +
- +	/* pressed now & were pressed, then held */
- +	gh3->btns_held = (now & gh3->btns);
- +
- +	/* were pressed or were held & not pressed now, then released */
- +	gh3->btns_released = ((gh3->btns | gh3->btns_held) & ~now);
- +
- +	/* buttons pressed now */
- +	gh3->btns = now;
- +}
- diff -ur wiiuse_v0.12/src/io.c wiiuse_v0.12_bb_final/src/io.c
- --- wiiuse_v0.12/src/io.c	2008-03-28 00:04:09.000000000 +0100
- +++ wiiuse_v0.12_bb_final/src/io.c	2009-10-12 11:10:24.000000000 +0200
- @@ -1,119 +1,119 @@
- -/*
- - *	wiiuse
- - *
- - *	Written By:
- - *		Michael Laforest	< para >
- - *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- - *
- - *	Copyright 2006-2007
- - *
- - *	This file is part of wiiuse.
- - *
- - *	This program is free software; you can redistribute it and/or modify
- - *	it under the terms of the GNU General Public License as published by
- - *	the Free Software Foundation; either version 3 of the License, or
- - *	(at your option) any later version.
- - *
- - *	This program is distributed in the hope that it will be useful,
- - *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- - *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- - *	GNU General Public License for more details.
- - *
- - *	You should have received a copy of the GNU General Public License
- - *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- - *
- - *	$Header$
- - *
- - */
- -
- -/**
- - *	@file
- - *	@brief Handles device I/O (non-OS specific).
- - */
- -
- -#include <stdio.h>
- -#include <stdlib.h>
- -
- -#include "definitions.h"
- -#include "wiiuse_internal.h"
- -#include "io.h"
- -
- -
- - /**
- - *	@brief Get initialization data from the wiimote.
- - *
- - *	@param wm		Pointer to a wiimote_t structure.
- - *	@param data		unused
- - *	@param len		unused
- - *
- - *	When first called for a wiimote_t structure, a request
- - *	is sent to the wiimote for initialization information.
- - *	This includes factory set accelerometer data.
- - *	The handshake will be concluded when the wiimote responds
- - *	with this data.
- - */
- -void wiiuse_handshake(struct wiimote_t* wm, byte* data, unsigned short len) {
- -	if (!wm)	return;
- -
- -	switch (wm->handshake_state) {
- -		case 0:
- -		{
- -			/* send request to wiimote for accelerometer calibration */
- +/*
- + *	wiiuse
- + *
- + *	Written By:
- + *		Michael Laforest	< para >
- + *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- + *
- + *	Copyright 2006-2007
- + *
- + *	This file is part of wiiuse.
- + *
- + *	This program is free software; you can redistribute it and/or modify
- + *	it under the terms of the GNU General Public License as published by
- + *	the Free Software Foundation; either version 3 of the License, or
- + *	(at your option) any later version.
- + *
- + *	This program is distributed in the hope that it will be useful,
- + *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- + *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- + *	GNU General Public License for more details.
- + *
- + *	You should have received a copy of the GNU General Public License
- + *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- + *
- + *	$Header$
- + *
- + */
- +
- +/**
- + *	@file
- + *	@brief Handles device I/O (non-OS specific).
- + */
- +
- +#include <stdio.h>
- +#include <stdlib.h>
- +
- +#include "definitions.h"
- +#include "wiiuse_internal.h"
- +#include "io.h"
- +
- +
- + /**
- + *	@brief Get initialization data from the wiimote.
- + *
- + *	@param wm		Pointer to a wiimote_t structure.
- + *	@param data		unused
- + *	@param len		unused
- + *
- + *	When first called for a wiimote_t structure, a request
- + *	is sent to the wiimote for initialization information.
- + *	This includes factory set accelerometer data.
- + *	The handshake will be concluded when the wiimote responds
- + *	with this data.
- + */
- +void wiiuse_handshake(struct wiimote_t* wm, byte* data, unsigned short len) {
- +	if (!wm)	return;
- +
- +	switch (wm->handshake_state) {
- +		case 0:
- +		{
- +			/* send request to wiimote for accelerometer calibration */
-  			byte* buf;
-  
- -			WIIMOTE_ENABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
- -			wiiuse_set_leds(wm, WIIMOTE_LED_NONE);
- -
- -			buf = (byte*)malloc(sizeof(byte) * 8);
- -			wiiuse_read_data_cb(wm, wiiuse_handshake, buf, WM_MEM_OFFSET_CALIBRATION, 7);
- -			wm->handshake_state++;
- -
- +			WIIMOTE_ENABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
- +			wiiuse_set_leds(wm, WIIMOTE_LED_NONE);
- +
- +			buf = (byte*)malloc(sizeof(byte) * 8);
- +			wiiuse_read_data_cb(wm, wiiuse_handshake, buf, WM_MEM_OFFSET_CALIBRATION, 7);
- +			wm->handshake_state++;
- +
-  			wiiuse_set_leds(wm, WIIMOTE_LED_NONE);
-  
- -			break;
- -		}
- -		case 1:
- -		{
- -			struct read_req_t* req = wm->read_req;
- -			struct accel_t* accel = &wm->accel_calib;
- -
- -			/* received read data */
- -			accel->cal_zero.x = req->buf[0];
- -			accel->cal_zero.y = req->buf[1];
- -			accel->cal_zero.z = req->buf[2];
- -
- -			accel->cal_g.x = req->buf[4] - accel->cal_zero.x;
- -			accel->cal_g.y = req->buf[5] - accel->cal_zero.y;
- -			accel->cal_g.z = req->buf[6] - accel->cal_zero.z;
- -
- -			/* done with the buffer */
- -			free(req->buf);
- -
- -			/* handshake is done */
- -			WIIUSE_DEBUG("Handshake finished. Calibration: Idle: X=%x Y=%x Z=%x\t+1g: X=%x Y=%x Z=%x",
- -					accel->cal_zero.x, accel->cal_zero.y, accel->cal_zero.z,
- -					accel->cal_g.x, accel->cal_g.y, accel->cal_g.z);
- -
- +			break;
- +		}
- +		case 1:
- +		{
- +			struct read_req_t* req = wm->read_req;
- +			struct accel_t* accel = &wm->accel_calib;
- +
- +			/* received read data */
- +			accel->cal_zero.x = req->buf[0];
- +			accel->cal_zero.y = req->buf[1];
- +			accel->cal_zero.z = req->buf[2];
- +
- +			accel->cal_g.x = req->buf[4] - accel->cal_zero.x;
- +			accel->cal_g.y = req->buf[5] - accel->cal_zero.y;
- +			accel->cal_g.z = req->buf[6] - accel->cal_zero.z;
- +
- +			/* done with the buffer */
- +			free(req->buf);
- +
- +			/* handshake is done */
- +			WIIUSE_DEBUG("Handshake finished. Calibration: Idle: X=%x Y=%x Z=%x\t+1g: X=%x Y=%x Z=%x",
- +					accel->cal_zero.x, accel->cal_zero.y, accel->cal_zero.z,
- +					accel->cal_g.x, accel->cal_g.y, accel->cal_g.z);
- +
-  
-  			/* request the status of the wiimote to see if there is an expansion */
-  			wiiuse_status(wm);
-  
- -			WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
- -			WIIMOTE_ENABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE_COMPLETE);
- +			WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
- +			WIIMOTE_ENABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE_COMPLETE);
-  			wm->handshake_state++;
-  
-  			/* now enable IR if it was set before the handshake completed */
-  			if (WIIMOTE_IS_SET(wm, WIIMOTE_STATE_IR)) {
- -				WIIUSE_DEBUG("Handshake finished, enabling IR.");
- -				WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_IR);
- -				wiiuse_set_ir(wm, 1);
- +				WIIUSE_DEBUG("Handshake finished, enabling IR.");
- +				WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_IR);
- +				wiiuse_set_ir(wm, 1);
-  			}
- -
- -			break;
- +
- +			break;
- +		}
- +		default:
- +		{
- +			break;
-  		}
- -		default:
- -		{
- -			break;
- -		}
- -	}
- -}
- +	}
- +}
- diff -ur wiiuse_v0.12/src/io_win.c wiiuse_v0.12_bb_final/src/io_win.c
- --- wiiuse_v0.12/src/io_win.c	2008-03-29 22:53:44.000000000 +0100
- +++ wiiuse_v0.12_bb_final/src/io_win.c	2009-10-06 15:25:00.000000000 +0200
- @@ -1,247 +1,247 @@
- -/*
- - *	wiiuse
- - *
- - *	Written By:
- - *		Michael Laforest	< para >
- - *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- - *
- - *	Copyright 2006-2007
- - *
- - *	This file is part of wiiuse.
- - *
- - *	This program is free software; you can redistribute it and/or modify
- - *	it under the terms of the GNU General Public License as published by
- - *	the Free Software Foundation; either version 3 of the License, or
- - *	(at your option) any later version.
- - *
- - *	This program is distributed in the hope that it will be useful,
- - *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- - *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- - *	GNU General Public License for more details.
- - *
- - *	You should have received a copy of the GNU General Public License
- - *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- - *
- - *	$Header$
- - *
- - */
- -
- -/**
- - *	@file
- - *	@brief Handles device I/O for Windows.
- - */
- -
- -#ifdef WIN32
- -
- -#include <stdio.h>
- -#include <stdlib.h>
- -
- -#include <windows.h>
- -#include <hidsdi.h>
- -#include <setupapi.h>
- -
- -#include "definitions.h"
- -#include "wiiuse_internal.h"
- -#include "io.h"
- -
- -
- -int wiiuse_find(struct wiimote_t** wm, int max_wiimotes, int timeout) {
- -	GUID device_id;
- -	HANDLE dev;
- -	HDEVINFO device_info;
- -	int i, index;
- -	DWORD len;
- -	SP_DEVICE_INTERFACE_DATA device_data;
- -	PSP_DEVICE_INTERFACE_DETAIL_DATA detail_data = NULL;
- -	HIDD_ATTRIBUTES	attr;
- -	int found = 0;
- -
- -	(void) timeout; // unused
- -
- -	device_data.cbSize = sizeof(device_data);
- -	index = 0;
- -
- -	/* get the device id */
- -	HidD_GetHidGuid(&device_id);
- -
- -	/* get all hid devices connected */
- -	device_info = SetupDiGetClassDevs(&device_id, NULL, NULL, (DIGCF_DEVICEINTERFACE | DIGCF_PRESENT));
- -
- -	for (;; ++index) {
- -
- -		if (detail_data) {
- -			free(detail_data);
- -			detail_data = NULL;
- -		}
- -
- -		/* query the next hid device info */
- -		if (!SetupDiEnumDeviceInterfaces(device_info, NULL, &device_id, index, &device_data))
- -			break;
- -
- -		/* get the size of the data block required */
- -		i = SetupDiGetDeviceInterfaceDetail(device_info, &device_data, NULL, 0, &len, NULL);
- -		detail_data = malloc(len);
- -		detail_data->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
- -
- -		/* query the data for this device */
- -		if (!SetupDiGetDeviceInterfaceDetail(device_info, &device_data, detail_data, len, NULL, NULL))
- -			continue;
- -
- -		/* open the device */
- -		dev = CreateFile(detail_data->DevicePath,
- -						(GENERIC_READ | GENERIC_WRITE),
- -						(FILE_SHARE_READ | FILE_SHARE_WRITE),
- -						NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
- -		if (dev == INVALID_HANDLE_VALUE)
- -			continue;
- -
- -		/* get device attributes */
- -		attr.Size = sizeof(attr);
- -		i = HidD_GetAttributes(dev, &attr);
- -
- -		if ((attr.VendorID == WM_VENDOR_ID) && (attr.ProductID == WM_PRODUCT_ID)) {
- -			/* this is a wiimote */
- -			wm[found]->dev_handle = dev;
- -
- -			wm[found]->hid_overlap.hEvent = CreateEvent(NULL, 1, 1, "");
- -			wm[found]->hid_overlap.Offset = 0;
- -			wm[found]->hid_overlap.OffsetHigh = 0;
- -
- -			WIIMOTE_ENABLE_STATE(wm[found], WIIMOTE_STATE_DEV_FOUND);
- -			WIIMOTE_ENABLE_STATE(wm[found], WIIMOTE_STATE_CONNECTED);
- -
- -			/* try to set the output report to see if the device is actually connected */
- -			if (!wiiuse_set_report_type(wm[found])) {
- -				WIIMOTE_DISABLE_STATE(wm[found], WIIMOTE_STATE_CONNECTED);
- -				continue;
- -			}
- -
- -			/* do the handshake */
- -			wiiuse_handshake(wm[found], NULL, 0);
- -
- -			WIIUSE_INFO("Connected to wiimote [id %i].", wm[found]->unid);
- -
- -			++found;
- -			if (found >= max_wiimotes)
- -				break;
- -		} else {
- -			/* not a wiimote */
- -			CloseHandle(dev);
- -		}
- -	}
- -
- -	if (detail_data)
- -		free(detail_data);
- -
- -	SetupDiDestroyDeviceInfoList(device_info);
- -
- -	return found;
- -}
- -
- -
- -int wiiuse_connect(struct wiimote_t** wm, int wiimotes) {
- -	int connected = 0;
- -	int i = 0;
- -
- -	for (; i < wiimotes; ++i) {
- -		if (WIIMOTE_IS_SET(wm[i], WIIMOTE_STATE_CONNECTED))
- -			++connected;
- -	}
- -
- -	return connected;
- -}
- -
- -
- -void wiiuse_disconnect(struct wiimote_t* wm) {
- -	if (!wm || WIIMOTE_IS_CONNECTED(wm))
- -		return;
- -
- -	CloseHandle(wm->dev_handle);
- -	wm->dev_handle = 0;
- -
- -	ResetEvent(&wm->hid_overlap);
- -
- -	wm->event = WIIUSE_NONE;
- -
- -	WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_CONNECTED);
- -	WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
- -}
- -
- -
- -int wiiuse_io_read(struct wiimote_t* wm) {
- -	DWORD b, r;
- -
- -	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
- -		return 0;
- -
- -	if (!ReadFile(wm->dev_handle, wm->event_buf, sizeof(wm->event_buf), &b, &wm->hid_overlap)) {
- -		/* partial read */
- +/*
- + *	wiiuse
- + *
- + *	Written By:
- + *		Michael Laforest	< para >
- + *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- + *
- + *	Copyright 2006-2007
- + *
- + *	This file is part of wiiuse.
- + *
- + *	This program is free software; you can redistribute it and/or modify
- + *	it under the terms of the GNU General Public License as published by
- + *	the Free Software Foundation; either version 3 of the License, or
- + *	(at your option) any later version.
- + *
- + *	This program is distributed in the hope that it will be useful,
- + *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- + *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- + *	GNU General Public License for more details.
- + *
- + *	You should have received a copy of the GNU General Public License
- + *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- + *
- + *	$Header$
- + *
- + */
- +
- +/**
- + *	@file
- + *	@brief Handles device I/O for Windows.
- + */
- +
- +#ifdef WIN32
- +
- +#include <stdio.h>
- +#include <stdlib.h>
- +
- +#include <windows.h>
- +#include <api/hidsdi.h>
- +#include <setupapi.h>
- +
- +#include "definitions.h"
- +#include "wiiuse_internal.h"
- +#include "io.h"
- +
- +
- +int wiiuse_find(struct wiimote_t** wm, int max_wiimotes, int timeout) {
- +	GUID device_id;
- +	HANDLE dev;
- +	HDEVINFO device_info;
- +	int i, index;
- +	DWORD len;
- +	SP_DEVICE_INTERFACE_DATA device_data;
- +	PSP_DEVICE_INTERFACE_DETAIL_DATA detail_data = NULL;
- +	HIDD_ATTRIBUTES	attr;
- +	int found = 0;
- +
- +	(void) timeout; // unused
- +
- +	device_data.cbSize = sizeof(device_data);
- +	index = 0;
- +
- +	/* get the device id */
- +	HidD_GetHidGuid(&device_id);
- +
- +	/* get all hid devices connected */
- +	device_info = SetupDiGetClassDevs(&device_id, NULL, NULL, (DIGCF_DEVICEINTERFACE | DIGCF_PRESENT));
- +
- +	for (;; ++index) {
- +
- +		if (detail_data) {
- +			free(detail_data);
- +			detail_data = NULL;
- +		}
- +
- +		/* query the next hid device info */
- +		if (!SetupDiEnumDeviceInterfaces(device_info, NULL, &device_id, index, &device_data))
- +			break;
- +
- +		/* get the size of the data block required */
- +		i = SetupDiGetDeviceInterfaceDetail(device_info, &device_data, NULL, 0, &len, NULL);
- +		detail_data = malloc(len);
- +		detail_data->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
- +
- +		/* query the data for this device */
- +		if (!SetupDiGetDeviceInterfaceDetail(device_info, &device_data, detail_data, len, NULL, NULL))
- +			continue;
- +
- +		/* open the device */
- +		dev = CreateFile(detail_data->DevicePath,
- +						(GENERIC_READ | GENERIC_WRITE),
- +						(FILE_SHARE_READ | FILE_SHARE_WRITE),
- +						NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
- +		if (dev == INVALID_HANDLE_VALUE)
- +			continue;
- +
- +		/* get device attributes */
- +		attr.Size = sizeof(attr);
- +		i = HidD_GetAttributes(dev, &attr);
- +
- +		if ((attr.VendorID == WM_VENDOR_ID) && (attr.ProductID == WM_PRODUCT_ID)) {
- +			/* this is a wiimote */
- +			wm[found]->dev_handle = dev;
- +
- +			wm[found]->hid_overlap.hEvent = CreateEvent(NULL, 1, 1, "");
- +			wm[found]->hid_overlap.Offset = 0;
- +			wm[found]->hid_overlap.OffsetHigh = 0;
- +
- +			WIIMOTE_ENABLE_STATE(wm[found], WIIMOTE_STATE_DEV_FOUND);
- +			WIIMOTE_ENABLE_STATE(wm[found], WIIMOTE_STATE_CONNECTED);
- +
- +			/* try to set the output report to see if the device is actually connected */
- +			if (!wiiuse_set_report_type(wm[found])) {
- +				WIIMOTE_DISABLE_STATE(wm[found], WIIMOTE_STATE_CONNECTED);
- +				continue;
- +			}
- +
- +			/* do the handshake */
- +			wiiuse_handshake(wm[found], NULL, 0);
- +
- +			WIIUSE_INFO("Connected to wiimote [id %i].", wm[found]->unid);
- +
- +			++found;
- +			if (found >= max_wiimotes)
- +				break;
- +		} else {
- +			/* not a wiimote */
- +			CloseHandle(dev);
- +		}
- +	}
- +
- +	if (detail_data)
- +		free(detail_data);
- +
- +	SetupDiDestroyDeviceInfoList(device_info);
- +
- +	return found;
- +}
- +
- +
- +int wiiuse_connect(struct wiimote_t** wm, int wiimotes) {
- +	int connected = 0;
- +	int i = 0;
- +
- +	for (; i < wiimotes; ++i) {
- +		if (WIIMOTE_IS_SET(wm[i], WIIMOTE_STATE_CONNECTED))
- +			++connected;
- +	}
- +
- +	return connected;
- +}
- +
- +
- +void wiiuse_disconnect(struct wiimote_t* wm) {
- +	if (!wm || WIIMOTE_IS_CONNECTED(wm))
- +		return;
- +
- +	CloseHandle(wm->dev_handle);
- +	wm->dev_handle = 0;
- +
- +	ResetEvent(&wm->hid_overlap);
- +
- +	wm->event = WIIUSE_NONE;
- +
- +	WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_CONNECTED);
- +	WIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);
- +}
- +
- +
- +int wiiuse_io_read(struct wiimote_t* wm) {
- +	DWORD b, r;
- +
- +	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
- +		return 0;
- +
- +	if (!ReadFile(wm->dev_handle, wm->event_buf, sizeof(wm->event_buf), &b, &wm->hid_overlap)) {
- +		/* partial read */
-  		b = GetLastError();
-  
- -		if ((b == ERROR_HANDLE_EOF) || (b == ERROR_DEVICE_NOT_CONNECTED)) {
- -			/* remote disconnect */
- -			wiiuse_disconnected(wm);
- -			return 0;
- -		}
- -
- -		r = WaitForSingleObject(wm->hid_overlap.hEvent, wm->timeout);
- -		if (r == WAIT_TIMEOUT) {
- +		if ((b == ERROR_HANDLE_EOF) || (b == ERROR_DEVICE_NOT_CONNECTED)) {
- +			/* remote disconnect */
- +			wiiuse_disconnected(wm);
- +			return 0;
- +		}
- +
- +		r = WaitForSingleObject(wm->hid_overlap.hEvent, wm->timeout);
- +		if (r == WAIT_TIMEOUT) {
-  			/* timeout - cancel and continue */
-  
-  			if (*wm->event_buf)
-  				WIIUSE_WARNING("Packet ignored.  This may indicate a problem (timeout is %i ms).", wm->timeout);
-  
- -			CancelIo(wm->dev_handle);
- -			ResetEvent(wm->hid_overlap.hEvent);
- -			return 0;
- -		} else if (r == WAIT_FAILED) {
- -			WIIUSE_WARNING("A wait error occured on reading from wiimote %i.", wm->unid);
- -			return 0;
- -		}
- -
- -		if (!GetOverlappedResult(wm->dev_handle, &wm->hid_overlap, &b, 0))
- -			return 0;
- -	}
- -
- +			CancelIo(wm->dev_handle);
- +			ResetEvent(wm->hid_overlap.hEvent);
- +			return 0;
- +		} else if (r == WAIT_FAILED) {
- +			WIIUSE_WARNING("A wait error occured on reading from wiimote %i.", wm->unid);
- +			return 0;
- +		}
- +
- +		if (!GetOverlappedResult(wm->dev_handle, &wm->hid_overlap, &b, 0))
- +			return 0;
- +	}
- +
-  	ResetEvent(wm->hid_overlap.hEvent);
- -	return 1;
- -}
- -
- -
- -int wiiuse_io_write(struct wiimote_t* wm, byte* buf, int len) {
- -	DWORD bytes;
- +	return 1;
- +}
- +
- +
- +int wiiuse_io_write(struct wiimote_t* wm, byte* buf, int len) {
- +	DWORD bytes;
-  	int i;
-  
- -	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
- +	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
-  		return 0;
-  
- -	switch (wm->stack) {
- -		case WIIUSE_STACK_UNKNOWN:
- -		{
- -			/* try to auto-detect the stack type */
- -			if (i = WriteFile(wm->dev_handle, buf, 22, &bytes, &wm->hid_overlap)) {
- -				/* bluesoleil will always return 1 here, even if it's not connected */
- +	switch (wm->stack) {
- +		case WIIUSE_STACK_UNKNOWN:
- +		{
- +			/* try to auto-detect the stack type */
- +			if (i = WriteFile(wm->dev_handle, buf, 22, &bytes, &wm->hid_overlap)) {
- +				/* bluesoleil will always return 1 here, even if it's not connected */
-  				wm->stack = WIIUSE_STACK_BLUESOLEIL;
- -				return i;
- -			}
- -
- -			if (i = HidD_SetOutputReport(wm->dev_handle, buf, len)) {
- -				wm->stack = WIIUSE_STACK_MS;
- -				return i;
- -			}
- -
- -			WIIUSE_ERROR("Unable to determine bluetooth stack type.");
- -			return 0;
- -		}
- -
- -		case WIIUSE_STACK_MS:
- -			return HidD_SetOutputReport(wm->dev_handle, buf, len);
- -
- -		case WIIUSE_STACK_BLUESOLEIL:
- -			return WriteFile(wm->dev_handle, buf, 22, &bytes, &wm->hid_overlap);
- -	}
- -
- -	return 0;
- -}
- -
- -#endif /* ifdef WIN32 */
- +				return i;
- +			}
- +
- +			if (i = HidD_SetOutputReport(wm->dev_handle, buf, len)) {
- +				wm->stack = WIIUSE_STACK_MS;
- +				return i;
- +			}
- +
- +			WIIUSE_ERROR("Unable to determine bluetooth stack type.");
- +			return 0;
- +		}
- +
- +		case WIIUSE_STACK_MS:
- +			return HidD_SetOutputReport(wm->dev_handle, buf, len);
- +
- +		case WIIUSE_STACK_BLUESOLEIL:
- +			return WriteFile(wm->dev_handle, buf, 22, &bytes, &wm->hid_overlap);
- +	}
- +
- +	return 0;
- +}
- +
- +#endif /* ifdef WIN32 */
- Only in wiiuse_v0.12/src/msvc: wiiuse.ncb
- Only in wiiuse_v0.12_bb_final/src/msvc: wiiuse.sln
- Only in wiiuse_v0.12_bb_final/src/msvc: wiiuse.vcproj
- Only in wiiuse_v0.12_bb_final/src/msvc: wiiuse.vcxproj
- Only in wiiuse_v0.12_bb_final/src/msvc: wiiuse.vcxproj.filters
- diff -ur wiiuse_v0.12/src/nunchuk.c wiiuse_v0.12_bb_final/src/nunchuk.c
- --- wiiuse_v0.12/src/nunchuk.c	2008-03-28 00:04:25.000000000 +0100
- +++ wiiuse_v0.12_bb_final/src/nunchuk.c	2009-10-07 17:47:46.000000000 +0200
- @@ -1,71 +1,71 @@
- -/*
- - *	wiiuse
- - *
- - *	Written By:
- - *		Michael Laforest	< para >
- - *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- - *
- - *	Copyright 2006-2007
- - *
- - *	This file is part of wiiuse.
- - *
- - *	This program is free software; you can redistribute it and/or modify
- - *	it under the terms of the GNU General Public License as published by
- - *	the Free Software Foundation; either version 3 of the License, or
- - *	(at your option) any later version.
- - *
- - *	This program is distributed in the hope that it will be useful,
- - *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- - *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- - *	GNU General Public License for more details.
- - *
- - *	You should have received a copy of the GNU General Public License
- - *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- - *
- - *	$Header$
- - *
- - */
- -
- -/**
- - *	@file
- - *	@brief Nunchuk expansion device.
- - */
- -
- -#include <stdio.h>
- -#include <stdlib.h>
- -#include <math.h>
- -
- -#include "definitions.h"
- -#include "wiiuse_internal.h"
- -#include "dynamics.h"
- -#include "events.h"
- -#include "nunchuk.h"
- -
- -static void nunchuk_pressed_buttons(struct nunchuk_t* nc, byte now);
- -
- -/**
- - *	@brief Handle the handshake data from the nunchuk.
- - *
- - *	@param nc		A pointer to a nunchuk_t structure.
- - *	@param data		The data read in from the device.
- - *	@param len		The length of the data block, in bytes.
- - *
- - *	@return	Returns 1 if handshake was successful, 0 if not.
- - */
- -int nunchuk_handshake(struct wiimote_t* wm, struct nunchuk_t* nc, byte* data, unsigned short len) {
- +/*
- + *	wiiuse
- + *
- + *	Written By:
- + *		Michael Laforest	< para >
- + *		Email: < thepara (--AT--) g m a i l [--DOT--] com >
- + *
- + *	Copyright 2006-2007
- + *
- + *	This file is part of wiiuse.
- + *
- + *	This program is free software; you can redistribute it and/or modify
- + *	it under the terms of the GNU General Public License as published by
- + *	the Free Software Foundation; either version 3 of the License, or
- + *	(at your option) any later version.
- + *
- + *	This program is distributed in the hope that it will be useful,
- + *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- + *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- + *	GNU General Public License for more details.
- + *
- + *	You should have received a copy of the GNU General Public License
- + *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
- + *
- + *	$Header$
- + *
- + */
- +
- +/**
- + *	@file
- + *	@brief Nunchuk expansion device.
- + */
- +
- +#include <stdio.h>
- +#include <stdlib.h>
- +#include <math.h>
- +
- +#include "definitions.h"
- +#include "wiiuse_internal.h"
- +#include "dynamics.h"
- +#include "events.h"
- +#include "nunchuk.h"
- +
- +static void nunchuk_pressed_buttons(struct nunchuk_t* nc, byte now);
- +
- +/**
- + *	@brief Handle the handshake data from the nunchuk.
- + *
- + *	@param nc		A pointer to a nunchuk_t structure.
- + *	@param data		The data read in from the device.
- + *	@param len		The length of the data block, in bytes.
- + *
- + *	@return	Returns 1 if handshake was successful, 0 if not.
- + */
- +int nunchuk_handshake(struct wiimote_t* wm, struct nunchuk_t* nc, byte* data, unsigned short len) {
-  	int i;
-  	int offset = 0;
-  
- -	nc->btns = 0;
- -	nc->btns_held = 0;
- -	nc->btns_released = 0;
- -
- -	/* set the smoothing to the same as the wiimote */
- -	nc->flags = &wm->flags;
- -	nc->accel_calib.st_alpha = wm->accel_calib.st_alpha;
- -
- -	/* decrypt data */
- -	for (i = 0; i < len; ++i)
- +	nc->btns = 0;
- +	nc->btns_held = 0;
- +	nc->btns_released = 0;
- +
- +	/* set the smoothing to the same as the wiimote */
- +	nc->flags = &wm->flags;
- +	nc->accel_calib.st_alpha = wm->accel_calib.st_alpha;
- +
- +	/* decrypt data */
- +	for (i = 0; i < len; ++i)
-  		data[i] = (data[i] ^ 0x17) + 0x17;
-  
-  	if (data[offset] == 0xFF) {
- @@ -89,122 +89,122 @@
-  			return 0;
-  		} else
-  			offset += 16;
- -	}
- -
- -	nc->accel_calib.cal_zero.x = data[offset + 0];
- -	nc->accel_calib.cal_zero.y = data[offset + 1];
- -	nc->accel_calib.cal_zero.z = data[offset + 2];
- -	nc->accel_calib.cal_g.x = data[offset + 4];
- -	nc->accel_calib.cal_g.y = data[offset + 5];
- -	nc->accel_calib.cal_g.z = data[offset + 6];
- -	nc->js.max.x = data[offset + 8];
- -	nc->js.min.x = data[offset + 9];
- -	nc->js.center.x = data[offset + 10];
- -	nc->js.max.y = data[offset + 11];
- -	nc->js.min.y = data[offset + 12];
- -	nc->js.center.y = data[offset + 13];
- -
- -	/* default the thresholds to the same as the wiimote */
- -	nc->orient_threshold = wm->orient_threshold;
- -	nc->accel_threshold = wm->accel_threshold;
- -
- +	}
- +
- +	nc->accel_calib.cal_zero.x = data[offset + 0];
- +	nc->accel_calib.cal_zero.y = data[offset + 1];
- +	nc->accel_calib.cal_zero.z = data[offset + 2];
- +	nc->accel_calib.cal_g.x = data[offset + 4];
- +	nc->accel_calib.cal_g.y = data[offset + 5];
- +	nc->accel_calib.cal_g.z = data[offset + 6];
- +	nc->js.max.x = data[offset + 8];
- +	nc->js.min.x = data[offset + 9];
- +	nc->js.center.x = data[offset + 10];
- +	nc->js.max.y = data[offset + 11];
- +	nc->js.min.y = data[offset + 12];
- +	nc->js.center.y = data[offset + 13];
- +
- +	/* default the thresholds to the same as the wiimote */
- +	nc->orient_threshold = wm->orient_threshold;
- +	nc->accel_threshold = wm->accel_threshold;
- +
-  	/* handshake done */
-  	wm->exp.type = EXP_NUNCHUK;
-  
-  	#ifdef WIN32
-  	wm->timeout = WIIMOTE_DEFAULT_TIMEOUT;
- -	#endif
- -
- -	return 1;
- -}
- -
- -
- -/**
- - *	@brief The nunchuk disconnected.
- - *
- - *	@param nc		A pointer to a nunchuk_t structure.
- - */
- -void nunchuk_disconnected(struct nunchuk_t* nc) {
- -	memset(nc, 0, sizeof(struct nunchuk_t));
- -}
- -
- -
- -
- -/**
- - *	@brief Handle nunchuk event.
- - *
- - *	@param nc		A pointer to a nunchuk_t structure.
- - *	@param msg		The message specified in the event packet.
- - */
- -void nunchuk_event(struct nunchuk_t* nc, byte* msg) {
- -	int i;
- -
- -	/* decrypt data */
- -	for (i = 0; i < 6; ++i)
- -		msg[i] = (msg[i] ^ 0x17) + 0x17;
- -
- -	/* get button states */
- -	nunchuk_pressed_buttons(nc, msg[5]);
- -
- -	/* calculate joystick state */
- -	calc_joystick_state(&nc->js, msg[0], msg[1]);
- -
- -	/* calculate orientation */
- -	nc->accel.x = msg[2];
- -	nc->accel.y = msg[3];
- -	nc->accel.z = msg[4];
- -
- -	calculate_orientation(&nc->accel_calib, &nc->accel, &nc->orient, NUNCHUK_IS_FLAG_SET(nc, WIIUSE_SMOOTHING));
- -	calculate_gforce(&nc->accel_calib, &nc->accel, &nc->gforce);
- -}
- -
- -
- -/**
- - *	@brief Find what buttons are pressed.
- - *
- - *	@param nc		Pointer to a nunchuk_t structure.
- - *	@param msg		The message byte specified in the event packet.
- - */
- -static void nunchuk_pressed_buttons(struct nunchuk_t* nc, byte now) {
- -	/* message is inverted (0 is active, 1 is inactive) */
- -	now = ~now & NUNCHUK_BUTTON_ALL;
- -
- -	/* pressed now & were pressed, then held */
- -	nc->btns_held = (now & nc->btns);
- -
- -	/* were pressed or were held & not pressed now, then released */
- -	nc->btns_released = ((nc->btns | nc->btns_held) & ~now);
- -
- -	/* buttons pressed now */
- -	nc->btns = now;
- -}
- -
- -
- -/**
- - *	@brief	Set the orientation event threshold for the nunchuk.
- - *
- - *	@param wm			Pointer to a wiimote_t structure with a nunchuk attached.
- - *	@param threshold	The decimal place that should be considered a significant change.
- - *
- - *	See wiiuse_set_orient_threshold() for details.
- - */
- -void wiiuse_set_nunchuk_orient_threshold(struct wiimote_t* wm, float threshold) {
- -	if (!wm)	return;
- -
- -	wm->exp.nunchuk.orient_threshold = threshold;
- -}
- -
- -
- -/**
- - *	@brief	Set the accelerometer event threshold for the nunchuk.
- - *
- - *	@param wm			Pointer to a wiimote_t structure with a nunchuk attached.
- - *	@param threshold	The decimal place that should be considered a significant change.
- - *
- - *	See wiiuse_set_orient_threshold() for details.
- - */
- -void wiiuse_set_nunchuk_accel_threshold(struct wiimote_t* wm, int threshold) {
- -	if (!wm)	return;
- -
- -	wm->exp.nunchuk.accel_threshold = threshold;
- -}
- +	#endif
- +
- +	return 1;
- +}
- +
- +
- +/**
- + *	@brief The nunchuk disconnected.
- + *
- + *	@param nc		A pointer to a nunchuk_t structure.
- + */
- +void nunchuk_disconnected(struct nunchuk_t* nc) {
- +	memset(nc, 0, sizeof(struct nunchuk_t));
- +}
- +
- +
- +
- +/**
- + *	@brief Handle nunchuk event.
- + *
- + *	@param nc		A pointer to a nunchuk_t structure.
- + *	@param msg		The message specified in the event packet.
- + */
- +void nunchuk_event(struct nunchuk_t* nc, byte* msg) {
- +	int i;
- +
- +	/* decrypt data */
- +	for (i = 0; i < 6; ++i)
- +		msg[i] = (msg[i] ^ 0x17) + 0x17;
- +
- +	/* get button states */
- +	nunchuk_pressed_buttons(nc, msg[5]);
- +
- +	/* calculate joystick state */
- +	calc_joystick_state(&nc->js, msg[0], msg[1]);
- +
- +	/* calculate orientation */
- +	nc->accel.x = msg[2];
- +	nc->accel.y = msg[3];
- +	nc->accel.z = msg[4];
- +
- +	calculate_orientation(&nc->accel_calib, &nc->accel, &nc->orient, NUNCHUK_IS_FLAG_SET(nc, WIIUSE_SMOOTHING));
- +	calculate_gforce(&nc->accel_calib, &nc->accel, &nc->gforce);
- +}
- +
- +
- +/**
- + *	@brief Find what buttons are pressed.
- + *
- + *	@param nc		Pointer to a nunchuk_t structure.
- + *	@param msg		The message byte specified in the event packet.
- + */
- +static void nunchuk_pressed_buttons(struct nunchuk_t* nc, byte now) {
- +	/* message is inverted (0 is active, 1 is inactive) */
- +	now = ~now & NUNCHUK_BUTTON_ALL;
- +
- +	/* pressed now & were pressed, then held */
- +	nc->btns_held = (now & nc->btns);
- +
- +	/* were pressed or were held & not pressed now, then released */
- +	nc->btns_released = ((nc->btns | nc->btns_held) & ~now);
- +
- +	/* buttons pressed now */
- +	nc->btns = now;
- +}
- +
- +
- +/**
- + *	@brief	Set the orientation event threshold for the nunchuk.
- + *
- + *	@param wm			Pointer to a wiimote_t structure with a nunchuk attached.
- + *	@param threshold	The decimal place that should be considered a significant change.
- + *
- + *	See wiiuse_set_orient_threshold() for details.
- + */
- +void wiiuse_set_nunchuk_orient_threshold(struct wiimote_t* wm, float threshold) {
- +	if (!wm)	return;
- +
- +	wm->exp.nunchuk.orient_threshold = threshold;
- +}
- +
- +
- +/**
- + *	@brief	Set the accelerometer event threshold for the nunchuk.
- + *
- + *	@param wm			Pointer to a wiimote_t structure with a nunchuk attached.
- + *	@param threshold	The decimal place that should be considered a significant change.
- + *
- + *	See wiiuse_set_orient_threshold() for details.
- + */
- +void wiiuse_set_nunchuk_accel_threshold(struct wiimote_t* wm, int threshold) {
- +	if (!wm)	return;
- +
- +	wm->exp.nunchuk.accel_threshold = threshold;
- +}
- Only in wiiuse_v0.12_bb_final/src: wiiboard.c
- Only in wiiuse_v0.12_bb_final/src: wiiboard.h
- diff -ur wiiuse_v0.12/src/wiiuse.c wiiuse_v0.12_bb_final/src/wiiuse.c
- --- wiiuse_v0.12/src/wiiuse.c	2008-03-28 00:29:27.000000000 +0100
- +++ wiiuse_v0.12_bb_final/src/wiiuse.c	2009-10-06 16:55:42.000000000 +0200
- @@ -360,7 +360,62 @@
-  	req->buf = buffer;
-  	req->addr = addr;
-  	req->size = len;
- -	req->wait = len;
- +	req->wait = len;
- +	req->dirty = 0;
- +	req->next = NULL;
- +
- +	/* add this to the request list */
- +	if (!wm->read_req) {
- +		/* root node */
- +		wm->read_req = req;
- +
- +		WIIUSE_DEBUG("Data read request can be sent out immediately.");
- +
- +		/* send the request out immediately */
- +		wiiuse_send_next_pending_read_request(wm);
- +	} else {
- +		struct read_req_t* nptr = wm->read_req;
- +		for (; nptr->next; nptr = nptr->next);
- +		nptr->next = req;
- +
- +		WIIUSE_DEBUG("Added pending data read request.");
- +	}
- +
- +	return 1;
- +}
- +
- +
- +/**
- + *	@brief	Read data from the wiimote (event version).
- + *
- + *	@param wm		Pointer to a wiimote_t structure.
- + *	@param buffer	An allocated buffer to store the data as it arrives from the wiimote.
- + *					Must be persistent in memory and large enough to hold the data.
- + *	@param addr		The address of wiimote memory to read from.
- + *	@param len		The length of the block to be read.
- + *
- + *	The library can only handle one data read request at a time
- + *	because it must keep track of the buffer and other
- + *	events that are specific to that request.  So if a request
- + *	has already been made, subsequent requests will be added
- + *	to a pending list and be sent out when the previous
- + *	finishes.
- + */
- +int wiiuse_read_data(struct wiimote_t* wm, byte* buffer, unsigned int addr, unsigned short len) {
- +	struct read_req_t* req;
- +
- +	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
- +		return 0;
- +	if (!buffer || !len)
- +		return 0;
- +
- +	/* make this request structure */
- +	req = (struct read_req_t*)malloc(sizeof(struct read_req_t));
- +	req->cb = NULL;
- +	req->buf = buffer;
- +	req->addr = addr;
- +	req->size = len;
- +	req->wait = len;
-  	req->dirty = 0;
-  	req->next = NULL;
-  
- @@ -385,61 +440,6 @@
-  }
-  
-  
- -/**
- - *	@brief	Read data from the wiimote (event version).
- - *
- - *	@param wm		Pointer to a wiimote_t structure.
- - *	@param buffer	An allocated buffer to store the data as it arrives from the wiimote.
- - *					Must be persistent in memory and large enough to hold the data.
- - *	@param addr		The address of wiimote memory to read from.
- - *	@param len		The length of the block to be read.
- - *
- - *	The library can only handle one data read request at a time
- - *	because it must keep track of the buffer and other
- - *	events that are specific to that request.  So if a request
- - *	has already been made, subsequent requests will be added
- - *	to a pending list and be sent out when the previous
- - *	finishes.
- - */
- -int wiiuse_read_data(struct wiimote_t* wm, byte* buffer, unsigned int addr, unsigned short len) {
- -	struct read_req_t* req;
- -
- -	if (!wm || !WIIMOTE_IS_CONNECTED(wm))
- -		return 0;
- -	if (!buffer || !len)
- -		return 0;
- -
- -	/* make this request structure */
- -	req = (struct read_req_t*)malloc(sizeof(struct read_req_t));
- -	req->cb = NULL;
- -	req->buf = buffer;
- -	req->addr = addr;
- -	req->size = len;
- -	req->wait = len;
- -	req->dirty = 0;
- -	req->next = NULL;
- -
- -	/* add this to the request list */
- -	if (!wm->read_req) {
- -		/* root node */
- -		wm->read_req = req;
- -
- -		WIIUSE_DEBUG("Data read request can be sent out immediately.");
- -
- -		/* send the request out immediately */
- -		wiiuse_send_next_pending_read_request(wm);
- -	} else {
- -		struct read_req_t* nptr = wm->read_req;
- -		for (; nptr->next; nptr = nptr->next);
- -		nptr->next = req;
- -
- -		WIIUSE_DEBUG("Added pending data read request.");
- -	}
- -
- -	return 1;
- -}
- -
- -
-  /**
-   *	@brief Send the next pending data read request to the wiimote.
-   *
- @@ -457,11 +457,11 @@
-  		return;
-  	if (!wm->read_req)	return;
-  
- -	/* skip over dirty ones since they have already been read */
- -	req = wm->read_req;
- -	while (req && req->dirty)
- -		req = req->next;
- -	if (!req)
- +	/* skip over dirty ones since they have already been read */
- +	req = wm->read_req;
- +	while (req && req->dirty)
- +		req = req->next;
- +	if (!req)
-  		return;
-  
-  	/* the offset is in big endian */
- diff -ur wiiuse_v0.12/src/wiiuse.h wiiuse_v0.12_bb_final/src/wiiuse.h
- --- wiiuse_v0.12/src/wiiuse.h	2008-04-02 01:14:16.000000000 +0200
- +++ wiiuse_v0.12_bb_final/src/wiiuse.h	2010-05-19 23:50:55.000000000 +0200
- @@ -128,6 +128,7 @@
-  #define EXP_NUNCHUK						1
-  #define EXP_CLASSIC						2
-  #define EXP_GUITAR_HERO_3				3
- +#define EXP_WII_BOARD					4
-  
-  /* IR correction types */
-  typedef enum ir_position_t {
- @@ -168,23 +169,23 @@
-   *	@param button	The button you are interested in.
-   *	@return 1 if the button is pressed, 0 if not.
-   */
- -#define IS_JUST_PRESSED(dev, button)	(IS_PRESSED(dev, button) && !IS_HELD(dev, button))
- -
- -/**
- - *	@brief Return the IR sensitivity level.
- - *	@param wm		Pointer to a wiimote_t structure.
- - *	@param lvl		[out] Pointer to an int that will hold the level setting.
- - *	If no level is set 'lvl' will be set to 0.
- - */
- -#define WIIUSE_GET_IR_SENSITIVITY(dev, lvl)									\
- -			do {														\
- -				if ((wm->state & 0x0200) == 0x0200) 		*lvl = 1;	\
- -				else if ((wm->state & 0x0400) == 0x0400) 	*lvl = 2;	\
- -				else if ((wm->state & 0x0800) == 0x0800) 	*lvl = 3;	\
- -				else if ((wm->state & 0x1000) == 0x1000) 	*lvl = 4;	\
- -				else if ((wm->state & 0x2000) == 0x2000) 	*lvl = 5;	\
- -				else									*lvl = 0;		\
- -			} while (0)
- +#define IS_JUST_PRESSED(dev, button)	(IS_PRESSED(dev, button) && !IS_HELD(dev, button))
- +
- +/**
- + *	@brief Return the IR sensitivity level.
- + *	@param wm		Pointer to a wiimote_t structure.
- + *	@param lvl		[out] Pointer to an int that will hold the level setting.
- + *	If no level is set 'lvl' will be set to 0.
- + */
- +#define WIIUSE_GET_IR_SENSITIVITY(dev, lvl)									\
- +			do {														\
- +				if ((wm->state & 0x0200) == 0x0200) 		*lvl = 1;	\
- +				else if ((wm->state & 0x0400) == 0x0400) 	*lvl = 2;	\
- +				else if ((wm->state & 0x0800) == 0x0800) 	*lvl = 3;	\
- +				else if ((wm->state & 0x1000) == 0x1000) 	*lvl = 4;	\
- +				else if ((wm->state & 0x2000) == 0x2000) 	*lvl = 5;	\
- +				else									*lvl = 0;		\
- +			} while (0)
-  
-  #define WIIUSE_USING_ACC(wm)			((wm->state & 0x020) == 0x020)
-  #define WIIUSE_USING_EXP(wm)			((wm->state & 0x040) == 0x040)
- @@ -242,7 +243,7 @@
-  	byte* buf;					/**< buffer where read data is written							*/
-  	unsigned int addr;			/**< the offset that the read started at						*/
-  	unsigned short size;		/**< the length of the data read								*/
- -	unsigned short wait;		/**< num bytes still needed to finish read						*/
- +	unsigned short wait;		/**< num bytes still needed to finish read						*/
-  	byte dirty;					/**< set to 1 if not using callback and needs to be cleaned up	*/
-  
-  	struct read_req_t* next;	/**< next read request in the queue								*/
- @@ -268,6 +269,15 @@
-  
-  
-  /**
- + *	@struct vec2f_t
- + *	@brief Signed x,y float struct.
- + */
- +typedef struct vec2f_t {
- +	float x, y;
- +} vec2f_t;
- +
- +
- +/**
-   *	@struct vec3f_t
-   *	@brief Signed x,y,z float struct.
-   */
- @@ -409,9 +419,9 @@
-  	byte btns;						/**< what buttons have just been pressed	*/
-  	byte btns_held;					/**< what buttons are being held down		*/
-  	byte btns_released;				/**< what buttons were just released this	*/
- -
- -	float orient_threshold;			/**< threshold for orient to generate an event */
- -	int accel_threshold;			/**< threshold for accel to generate an event */
- +
- +	float orient_threshold;			/**< threshold for orient to generate an event */
- +	int accel_threshold;			/**< threshold for accel to generate an event */
-  
-  	struct vec3b_t accel;			/**< current raw acceleration data			*/
-  	struct orient_t orient;			/**< current orientation on each axis		*/
- @@ -450,6 +460,29 @@
-  	struct joystick_t js;			/**< joystick calibration					*/
-  } guitar_hero_3_t;
-  
- +/*
- +	Wii board
- +*/
- +typedef struct wii_board_4s_t {
- +	short tl, tr, bl, br;
- +} wii_board_4s_t;
- +
- +typedef struct wii_board_4f_t {
- +	float tl, tr, bl, br;
- +} wii_board_4f_t;
- +
- +typedef struct wii_board_t {
- +	wii_board_4f_t norm; /* final value, normalized (range -1, 1 !CAN GO OUT THAT RANGE!) */
- +	wii_board_4f_t val; /* final value, not normalized (range -k, k, k = 136Kg !CAN GO OUT THAT RANGE!) */
- +	wii_board_4s_t raw; /* RAW */
- +	wii_board_4s_t hs[3]; /* handshake data */
- +	wii_board_4s_t cal; /* calibration data */
- +	wii_board_4s_t prev; /* previous data */
- +	wii_board_4s_t delta; /* difference between hs[2] and hs[0] */
- +	vec2f_t pos; /* weight position (-1, 1)*/
- +	float weight;
- +} wii_board_t;
- +
-  
-  /**
-   *	@struct expansion_t
- @@ -457,11 +490,11 @@
-   */
-  typedef struct expansion_t {
-  	int type;						/**< type of expansion attached				*/
- -
-  	union {
-  		struct nunchuk_t nunchuk;
-  		struct classic_ctrl_t classic;
-  		struct guitar_hero_3_t gh3;
- +		struct wii_board_t wb;
-  	};
-  } expansion_t;
-  
- @@ -489,7 +522,7 @@
-  	float exp_rjs_mag;
-  	unsigned short exp_btns;
-  	struct orient_t exp_orient;
- -	struct vec3b_t exp_accel;
- +	struct vec3b_t exp_accel;
-  	float exp_r_shoulder;
-  	float exp_l_shoulder;
-  
- @@ -512,17 +545,19 @@
-  typedef enum WIIUSE_EVENT_TYPE {
-  	WIIUSE_NONE = 0,
-  	WIIUSE_EVENT,
- -	WIIUSE_STATUS,
- +	WIIUSE_STATUS,
-  	WIIUSE_CONNECT,
- -	WIIUSE_DISCONNECT,
- -	WIIUSE_UNEXPECTED_DISCONNECT,
- -	WIIUSE_READ_DATA,
- +	WIIUSE_DISCONNECT,
- +	WIIUSE_UNEXPECTED_DISCONNECT,
- +	WIIUSE_READ_DATA,
-  	WIIUSE_NUNCHUK_INSERTED,
- -	WIIUSE_NUNCHUK_REMOVED,
- -	WIIUSE_CLASSIC_CTRL_INSERTED,
- -	WIIUSE_CLASSIC_CTRL_REMOVED,
- -	WIIUSE_GUITAR_HERO_3_CTRL_INSERTED,
- -	WIIUSE_GUITAR_HERO_3_CTRL_REMOVED
- +	WIIUSE_NUNCHUK_REMOVED,
- +	WIIUSE_CLASSIC_CTRL_INSERTED,
- +	WIIUSE_CLASSIC_CTRL_REMOVED,
- +	WIIUSE_GUITAR_HERO_3_CTRL_INSERTED,
- +	WIIUSE_GUITAR_HERO_3_CTRL_REMOVED,
- +	WIIUSE_WII_BOARD_CTRL_INSERTED,
- +	WIIUSE_WII_BOARD_CTRL_REMOVED
-  } WIIUSE_EVENT_TYPE;
-  
-  /**
- @@ -550,8 +585,8 @@
-  	WCONST byte leds;						/**< currently lit leds						*/
-  	WCONST float battery_level;				/**< battery level							*/
-  
- -	WCONST int flags;						/**< options flag							*/
- -
- +	WCONST int flags;						/**< options flag							*/
- +
-  	WCONST byte handshake_state;			/**< the state of the connection handshake	*/
-  
-  	WCONST struct read_req_t* read_req;		/**< list of data read requests				*/
- @@ -636,13 +671,15 @@
-  WIIUSE_EXPORT extern void wiiuse_set_ir(struct wiimote_t* wm, int status);
-  WIIUSE_EXPORT extern void wiiuse_set_ir_vres(struct wiimote_t* wm, unsigned int x, unsigned int y);
-  WIIUSE_EXPORT extern void wiiuse_set_ir_position(struct wiimote_t* wm, enum ir_position_t pos);
- -WIIUSE_EXPORT extern void wiiuse_set_aspect_ratio(struct wiimote_t* wm, enum aspect_t aspect);
- -WIIUSE_EXPORT extern void wiiuse_set_ir_sensitivity(struct wiimote_t* wm, int level);
- -
- -/* nunchuk.c */
- -WIIUSE_EXPORT extern void wiiuse_set_nunchuk_orient_threshold(struct wiimote_t* wm, float threshold);
- -WIIUSE_EXPORT extern void wiiuse_set_nunchuk_accel_threshold(struct wiimote_t* wm, int threshold);
- +WIIUSE_EXPORT extern void wiiuse_set_aspect_ratio(struct wiimote_t* wm, enum aspect_t aspect);
- +WIIUSE_EXPORT extern void wiiuse_set_ir_sensitivity(struct wiimote_t* wm, int level);
- +
- +/* nunchuk.c */
- +WIIUSE_EXPORT extern void wiiuse_set_nunchuk_orient_threshold(struct wiimote_t* wm, float threshold);
- +WIIUSE_EXPORT extern void wiiuse_set_nunchuk_accel_threshold(struct wiimote_t* wm, int threshold);
-  
- +/* Balance Board */
- +WIIUSE_EXPORT extern void wiiuse_set_wii_board_calib(struct wiimote_t *wm);
-  
-  #ifdef __cplusplus
-  }
- diff -ur wiiuse_v0.12/src/wiiuse_internal.h wiiuse_v0.12_bb_final/src/wiiuse_internal.h
- --- wiiuse_v0.12/src/wiiuse_internal.h	2008-03-29 22:58:04.000000000 +0100
- +++ wiiuse_v0.12_bb_final/src/wiiuse_internal.h	2010-05-19 23:43:59.000000000 +0200
- @@ -152,9 +152,10 @@
-  #define EXP_ID_CODE_NUNCHUK					0x9A1EFEFE
-  #define EXP_ID_CODE_CLASSIC_CONTROLLER		0x9A1EFDFD
-  #define EXP_ID_CODE_GUITAR					0x9A1EFDFB
- +#define EXP_ID_CODE_WII_BOARD				0xA4200402
- +
- +#define EXP_HANDSHAKE_LEN					224
-  
- -#define EXP_HANDSHAKE_LEN					224
- -
-  /********************
-   *
-   *	End Wiimote internal codes
- @@ -205,10 +206,10 @@
-  #define WIIUSE_DEFAULT_SMOOTH_ALPHA		0.07f
-  
-  #define SMOOTH_ROLL						0x01
- -#define SMOOTH_PITCH					0x02
- -
- +#define SMOOTH_PITCH					0x02
- +
-  #include "wiiuse.h"
- -
- +
-  #ifdef __cplusplus
-  extern "C" {
-  #endif
--- 0 ----
